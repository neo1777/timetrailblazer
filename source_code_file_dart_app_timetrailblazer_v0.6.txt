./lib/constants.dart:
```
import 'package:flutter/material.dart';

// Costanti per i colori
const Color primaryColor = Colors.blue;
const Color secondaryColor = Colors.white;
const Color errorColor = Colors.red;
const Color shadowColor = Colors.black;
const Color entryColor = Colors.green;
const Color exitColor = Colors.red;

// Costanti per le dimensioni
const double buttonPaddingV = 16.0;
const double buttonPaddingH = 32.0;
const double buttonElevation = 2.0;

// Costanti per i testi
const String entryRegistered = 'Entrata registrata';
const String exitRegistered = 'Uscita registrata';
const String appTitle = 'Registrazione Orari di Lavoro';
const String homeTitle = 'Registrazione orari di lavoro';
const String workEntriesTitle = 'Registrazioni Orari di Lavoro';
const String confirmResetTitle = 'Conferma Reset';
const String confirmResetMessage =
    'Sei sicuro di voler resettare il database? Questa azione è irreversibile.';
const String cancelButtonText = 'Annulla';
const String confirmButtonText = 'Conferma';
const String csvExportSuccess = 'File CSV esportato in';
const String csvExportError = 'Errore durante l\'esportazione CSV:';
const String databaseResetSuccess = 'Database resettato con successo';
const String databaseResetError = 'Errore durante il reset del database:';
const String dataLoadError = 'Errore nel caricamento dei dati';

// Costanti per le notifiche di errore
const String insertEntryError =
    'Errore durante l\'inserimento della voce di lavoro';
const String getEntriesError =
    'Errore durante il recupero delle voci di lavoro';
const String resetDatabaseError = 'Errore durante il reset del database';

```

./lib/main.dart:
```
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:intl/date_symbol_data_local.dart';
import 'package:pine/pine.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import 'package:timetrailblazer/app.dart';
import 'package:timetrailblazer/data/database_helper.dart';
import 'package:timetrailblazer/dependencies/bloc_providers.dart';
import 'package:timetrailblazer/dependencies/mappers.dart';
import 'package:timetrailblazer/dependencies/providers.dart';
import 'package:timetrailblazer/dependencies/repositories.dart';
import 'package:timetrailblazer/utils/logger.dart';


/// Il punto di ingresso dell'applicazione TimeTrailBlazer.
/// 
/// Inizializza il database, configura le dipendenze e avvia l'applicazione.
void main() async {
  // Assicura che i binding di Flutter siano inizializzati prima di eseguire il codice dell'app
  WidgetsFlutterBinding.ensureInitialized();

  // Inizializza la formattazione delle date per la lingua italiana
  await initializeDateFormatting('it_IT', null);

  // Verifica se l'app è in esecuzione su Windows o Linux
  if (Platform.isWindows || Platform.isLinux) {
    // Inizializza FFI (Foreign Function Interface) per Windows e Linux
    // Questo è necessario per utilizzare il database SQLite su queste piattaforme
    sqfliteFfiInit();
    databaseFactory = databaseFactoryFfi;
  }

  // Crea un'istanza di DatabaseHelper per gestire il database dell'app
  final databaseHelper = DatabaseHelper();

  /// Avvia l'applicazione Flutter.
  /// 
  /// Utilizza un [FutureBuilder] per inizializzare il database e configurare le dipendenze.
  /// In caso di errore durante l'inizializzazione del database, mostra un messaggio di errore.
  /// Altrimenti, avvia l'applicazione con le dipendenze configurate.
  runApp(
    FutureBuilder(
      future: databaseHelper.initializeDatabase(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.done) {
          if (snapshot.hasError) {
            // Registra l'errore utilizzando logger
            logger.e('Errore durante l\'inizializzazione del database',
                error: snapshot.error);
            // Mostra un messaggio di errore in caso di errore durante l'inizializzazione del database
            return MaterialApp(
              home: Scaffold(
                body: Center(
                  child: Text(
                    'Errore durante l\'inizializzazione del database: ${snapshot.error}. Si prega di verificare che il dispositivo abbia spazio sufficiente e che l\'applicazione abbia i permessi necessari per creare il database. Se il problema persiste, contattare l\'assistenza.',
                  ),
                ),
              ),
            );
          } else {
            // Avvia l'applicazione Flutter dopo l'inizializzazione del database
            return DependencyInjectorHelper(
              mappers: getMappers(),
              providers: getProviders(databaseHelper),
              repositories: getRepositories(),
              blocs: getBlocProviders(),
              child: const App(),
            );
          }
        } else {
          // Mostra un indicatore di caricamento durante l'inizializzazione del database
          return const MaterialApp(
            home: Scaffold(
              body: Center(
                child: CircularProgressIndicator(),
              ),
            ),
          );
        }
      },
    ),
  );
}

```

./lib/domain/blocs/home_page/home_bloc.dart:
```
import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

part 'home_event.dart';
part 'home_state.dart';

/// Il BLoC che gestisce lo stato della schermata principale.
class HomeBloc extends Bloc<HomeEvent, HomeState> {
  /// Costruttore del BLoC.
  ///
  /// Inizializza lo stato iniziale del BLoC a `HomePageInitial`.
  HomeBloc() : super(const HomePageInitial()) {
    /// Gestisce l'evento `EntryButtonPressed`.
    on<EntryButtonPressed>(_onEntryButtonPressed);

    /// Gestisce l'evento `ExitButtonPressed`.
    on<ExitButtonPressed>(_onExitButtonPressed);
  }

  /// Gestore dell'evento `EntryButtonPressed`.
  ///
  /// Quando viene premuto il pulsante di entrata, emette lo stato `HomePageExitButtonDisabled`.
  void _onEntryButtonPressed(
      EntryButtonPressed event, Emitter<HomeState> emit) {
    emit(const HomePageExitButtonDisabled());
  }

  /// Gestore dell'evento `ExitButtonPressed`.
  ///
  /// Quando viene premuto il pulsante di uscita, emette lo stato `HomePageEntryButtonDisabled`.
  void _onExitButtonPressed(ExitButtonPressed event, Emitter<HomeState> emit) {
    emit(const HomePageEntryButtonDisabled());
  }
}

```

./lib/domain/blocs/home_page/home_state.dart:
```
part of 'home_bloc.dart';

/// Rappresenta lo stato del BLoC `HomeBloc`.
abstract class HomeState extends Equatable {
  /// Indica se il pulsante di entrata è abilitato.
  final bool isEntryButtonEnabled;

  /// Indica se il pulsante di uscita è abilitato.
  final bool isExitButtonEnabled;

  const HomeState({
    required this.isEntryButtonEnabled,
    required this.isExitButtonEnabled,
  });

  @override
  List<Object> get props => [isEntryButtonEnabled, isExitButtonEnabled];
}

/// Rappresenta lo stato iniziale del BLoC `HomeBloc`.
class HomePageInitial extends HomeState {
  const HomePageInitial()
      : super(
          isEntryButtonEnabled: true,
          isExitButtonEnabled: false,
        );
}

/// Rappresenta lo stato in cui il pulsante di entrata è disabilitato.
class HomePageEntryButtonDisabled extends HomeState {
  const HomePageEntryButtonDisabled()
      : super(
          isEntryButtonEnabled: false,
          isExitButtonEnabled: true,
        );
}

/// Rappresenta lo stato in cui il pulsante di uscita è disabilitato.
class HomePageExitButtonDisabled extends HomeState {
  const HomePageExitButtonDisabled()
      : super(
          isEntryButtonEnabled: true,
          isExitButtonEnabled: false,
        );
}

```

./lib/domain/blocs/home_page/home_event.dart:
```
// home_page_event.dart
part of 'home_bloc.dart';

/// Rappresenta un evento del BLoC `HomeBloc`.
abstract class HomeEvent extends Equatable {
  const HomeEvent();
}

/// Rappresenta l'evento di pressione del pulsante di entrata.
class EntryButtonPressed extends HomeEvent {
  @override
  List<Object> get props => [];
}

/// Rappresenta l'evento di pressione del pulsante di uscita.
class ExitButtonPressed extends HomeEvent {
  @override
  List<Object> get props => [];
}

```

./lib/domain/blocs/work_entries/work_entries_event.dart:
```
part of 'work_entries_bloc.dart';

/// Classe astratta che rappresenta un evento del `WorkEntriesBloc`.
abstract class WorkEntriesEvent extends Equatable {
  const WorkEntriesEvent();
}

/// Evento per recuperare le voci di lavoro.
class FetchWorkEntries extends WorkEntriesEvent {
  final DateTime startDate;
  final DateTime endDate;

  const FetchWorkEntries({
    required this.startDate,
    required this.endDate,
  });

  @override
  List<Object> get props => [
        startDate,
        endDate,
      ];
}

/// Evento per aggiungere una nuova voce di lavoro.
class AddWorkEntry extends WorkEntriesEvent {
  final WorkEntry entry;

  const AddWorkEntry(this.entry);

  @override
  List<Object> get props => [entry];
}

/// Evento per aggiornare una voce di lavoro esistente.
class UpdateWorkEntry extends WorkEntriesEvent {
  final WorkEntry entry;

  const UpdateWorkEntry(this.entry);

  @override
  List<Object> get props => [entry];
}

/// Evento per eliminare una voce di lavoro.
class DeleteWorkEntry extends WorkEntriesEvent {
  final int entryId;
  final DateTime day;

  const DeleteWorkEntry(this.entryId, this.day);

  @override
  List<Object> get props => [entryId, day];
}

/// Evento per eliminare tutte le voci di lavoro.
class DeleteAllWorkEntries extends WorkEntriesEvent {
  final DateTime startDate;
  final DateTime endDate;

  const DeleteAllWorkEntries(this.startDate, this.endDate);

  @override
  List<Object> get props => [startDate, endDate];
}

/// Evento per aggiornare l'intervallo di date di inizio e fine.
class UpdateDateRange extends WorkEntriesEvent {
  final DateTime startDate;
  final DateTime endDate;

  const UpdateDateRange(this.startDate, this.endDate);

  @override
  List<Object?> get props => [startDate, endDate];
}

```

./lib/domain/blocs/work_entries/work_entries_state.dart:
```
part of 'work_entries_bloc.dart';

/// Classe astratta che rappresenta uno stato del `WorkEntriesBloc`.
abstract class WorkEntriesState extends Equatable {
  const WorkEntriesState();
}

/// Stato iniziale del `WorkEntriesBloc`.
class WorkEntriesInitial extends WorkEntriesState {
  @override
  List<Object> get props => [];
}

/// Stato che rappresenta il caricamento delle voci di lavoro.
class WorkEntriesLoading extends WorkEntriesState {
  @override
  List<Object> get props => [];
}

/// Stato che rappresenta le voci di lavoro caricate.
class WorkEntriesLoaded extends WorkEntriesState {
  /// La lista delle voci di lavoro caricate.
  final List<WorkEntry> entries;
  
  /// Le voci di lavoro raggruppate per giorno.
  final Map<DateTime, List<WorkEntry>> entriesGroupedByDay;

  const WorkEntriesLoaded(this.entries, this.entriesGroupedByDay);

  @override
  List<Object> get props => [entries, entriesGroupedByDay];
}

/// Stato che rappresenta un errore durante il caricamento delle voci di lavoro.
class WorkEntriesError extends WorkEntriesState {
  /// Il messaggio di errore.
  final String message;

  const WorkEntriesError(this.message);

  @override
  List<Object> get props => [message];
}

/// Stato che rappresenta l'aggiornamento dell'intervallo di date di inizio e fine.
class WorkEntriesDateRangeUpdated extends WorkEntriesState {
  final DateTime startDate; // La nuova data di inizio (può essere null)
  final DateTime endDate; // La nuova data di fine (può essere null)

  const WorkEntriesDateRangeUpdated(this.startDate, this.endDate);

  @override
  List<Object?> get props => [startDate, endDate];
}

```

./lib/domain/blocs/work_entries/work_entries_bloc.dart:
```
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:timetrailblazer/data/dependencies/repositories/work_entries_repository.dart';
import 'package:timetrailblazer/domain/entities/work_entry.dart';
import 'package:timetrailblazer/utils/logger.dart';

part 'work_entries_event.dart';
part 'work_entries_state.dart';

/// Il `WorkEntriesBloc` gestisce lo stato e gli eventi relativi alle voci di lavoro.
class WorkEntriesBloc extends Bloc<WorkEntriesEvent, WorkEntriesState> {
  final WorkEntriesRepositoryImpl _workEntriesRepository;

  /// Costruttore del `WorkEntriesBloc` che accetta un `WorkEntriesRepository`.
  WorkEntriesBloc(this._workEntriesRepository) : super(WorkEntriesInitial()) {
    // Gestisce l'evento `FetchWorkEntries` per recuperare le voci di lavoro.
    on<FetchWorkEntries>(_onFetchWorkEntries);
    // Gestisce l'evento `AddWorkEntry` per aggiungere una nuova voce di lavoro.
    on<AddWorkEntry>(_onAddWorkEntry);
    // Gestisce l'evento `UpdateWorkEntry` per aggiornare una voce di lavoro esistente.
    on<UpdateWorkEntry>(_onUpdateWorkEntry);
    // Gestisce l'evento `DeleteWorkEntry` per eliminare una voce di lavoro.
    on<DeleteWorkEntry>(_onDeleteWorkEntry);
    // Gestisce l'evento `DeleteAllWorkEntries` per eliminare tutte le voci di lavoro.
    on<DeleteAllWorkEntries>(_onDeleteAllWorkEntries);
    // Gestisce l'evento `UpdateDateRange` per aggiornare l'intervallo di date di inizio e fine.
    on<UpdateDateRange>(_onUpdateDateRange);
  }

  /// Gestore dell'evento `FetchWorkEntries`.
  /// Recupera le voci di lavoro dal repository e le emette nello stato `WorkEntriesLoaded`.
  Future<void> _onFetchWorkEntries(
    FetchWorkEntries event,
    Emitter<WorkEntriesState> emit,
  ) async {
    emit(WorkEntriesLoading());
    try {
      final entries = await _workEntriesRepository.getWorkEntries(
        event.startDate,
        event.endDate,
      );
      final sortedEntries = entries.toList()
        ..sort((a, b) => a.timestamp.compareTo(b.timestamp));
      emit(WorkEntriesLoaded(sortedEntries, _groupEntriesByDay(sortedEntries)));
    } catch (e) {
      logger.e('Errore durante il recupero delle voci di lavoro', error: e);
      emit(WorkEntriesError(
          'Errore durante il recupero delle voci di lavoro: ${e.toString()}. Si prega di riprovare più tardi o contattare l\'assistenza se il problema persiste.'));
    }
  }

  /// Raggruppa le voci di lavoro per giorno.
  ///
  /// Parametri:
  ///   - entries: la lista delle voci di lavoro da raggruppare.
  ///
  /// Restituisce una mappa che associa ogni giorno alle voci di lavoro corrispondenti.
  Map<DateTime, List<WorkEntry>> _groupEntriesByDay(List<WorkEntry> entries) {
    Map<DateTime, List<WorkEntry>> entriesGroupedByDay = {};
    for (var entry in entries) {
      final day = DateTime(entry.day.year, entry.day.month, entry.day.day);
      if (entriesGroupedByDay.containsKey(day)) {
        entriesGroupedByDay[day]!.add(entry);
      } else {
        entriesGroupedByDay[day] = [entry];
      }
    }
    return entriesGroupedByDay;
  }

  /// Gestore dell'evento `AddWorkEntry`.
  /// Aggiunge una nuova voce di lavoro tramite il repository e recupera nuovamente le voci di lavoro.
  Future<void> _onAddWorkEntry(
    AddWorkEntry event,
    Emitter<WorkEntriesState> emit,
  ) async {
    try {
      await _workEntriesRepository.insertWorkEntry(event.entry);
      add(FetchWorkEntries(
        startDate: event.entry.day,
        endDate: event.entry.day.add(const Duration(days: 1)),
      ));
    } catch (e) {
      logger.e('Errore durante l\'aggiunta di una nuova voce di lavoro',
          error: e);
      emit(WorkEntriesError(
          'Errore durante l\'operazione sulle voci di lavoro: ${e.toString()}. Si prega di verificare la connessione di rete e riprovare. Se il problema persiste, contattare l\'assistenza.'));
    }
  }

  /// Gestore dell'evento `UpdateWorkEntry`.
  /// Aggiorna una voce di lavoro esistente tramite il repository e recupera nuovamente le voci di lavoro.
  Future<void> _onUpdateWorkEntry(
    UpdateWorkEntry event,
    Emitter<WorkEntriesState> emit,
  ) async {
    try {
      await _workEntriesRepository.updateWorkEntry(event.entry);
      add(FetchWorkEntries(
        startDate: event.entry.day,
        endDate: event.entry.day.add(const Duration(days: 1)),
      ));
    } catch (e) {
      logger.e('Errore durante l\'aggiornamento di una voce di lavoro',
          error: e);
      emit(WorkEntriesError(
          'Errore durante l\'operazione sulle voci di lavoro: ${e.toString()}. Si prega di verificare la connessione di rete e riprovare. Se il problema persiste, contattare l\'assistenza.'));
    }
  }

  /// Gestore dell'evento `DeleteWorkEntry`.
  /// Elimina una voce di lavoro tramite il repository e recupera nuovamente le voci di lavoro.
  Future<void> _onDeleteWorkEntry(
    DeleteWorkEntry event,
    Emitter<WorkEntriesState> emit,
  ) async {
    try {
      await _workEntriesRepository.deleteWorkEntry(event.entryId);
      add(FetchWorkEntries(
        startDate: event.day,
        endDate: event.day.add(const Duration(days: 1)),
      ));
    } catch (e) {
      logger.e('Errore durante l\'eliminazione di una voce di lavoro',
          error: e);
      emit(WorkEntriesError(
          'Errore durante l\'operazione sulle voci di lavoro: ${e.toString()}. Si prega di verificare la connessione di rete e riprovare. Se il problema persiste, contattare l\'assistenza.'));
    }
  }

  /// Gestore dell'evento `DeleteAllWorkEntries`.
  /// Elimina tutte le voci di lavoro tramite il repository e recupera nuovamente le voci di lavoro.
  Future<void> _onDeleteAllWorkEntries(
    DeleteAllWorkEntries event,
    Emitter<WorkEntriesState> emit,
  ) async {
    try {
      await _workEntriesRepository.deleteAllWorkEntries();

      add(FetchWorkEntries(
        startDate: event.startDate,
        endDate: event.endDate,
      ));
    } catch (e) {
      logger.e('Errore durante l\'eliminazione di tutte le voci di lavoro',
          error: e);
      emit(WorkEntriesError(
          'Errore durante l\'operazione sulle voci di lavoro: ${e.toString()}. Si prega di verificare la connessione di rete e riprovare. Se il problema persiste, contattare l\'assistenza.'));
    }
  }

  /// Gestore dell'evento `UpdateDateRange`.
  /// Emette lo stato `WorkEntriesDateRangeUpdated` con le nuove date di inizio e fine.
  Future<void> _onUpdateDateRange(
    UpdateDateRange event,
    Emitter<WorkEntriesState> emit,
  ) async {
    emit(WorkEntriesDateRangeUpdated(event.startDate, event.endDate));
  }
}

```

./lib/domain/blocs/edit_work_entry/edit_work_entry_bloc.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:timetrailblazer/domain/entities/work_entry.dart';
import 'package:timetrailblazer/utils/logger.dart';

part 'edit_work_entry_event.dart';
part 'edit_work_entry_state.dart';

/// Il `EditWorkEntryBloc` gestisce lo stato e gli eventi relativi alla modifica di una voce di lavoro.
class EditWorkEntryBloc extends Bloc<EditWorkEntryEvent, EditWorkEntryState> {
  /// Costruttore del `EditWorkEntryBloc` che accetta una `WorkEntry` iniziale.
  EditWorkEntryBloc(WorkEntry initialWorkEntry)
      : super(EditWorkEntryInitial(initialWorkEntry)) {
    // Gestisce l'evento `UpdateDate` per aggiornare la data della voce di lavoro.
    on<UpdateDate>(_onUpdateDate);
    // Gestisce l'evento `UpdateTime` per aggiornare l'ora della voce di lavoro.
    on<UpdateTime>(_onUpdateTime);
  }

  /// Gestore dell'evento `UpdateDate`.
  /// Aggiorna la data della voce di lavoro nello stato corrente.
  void _onUpdateDate(UpdateDate event, Emitter<EditWorkEntryState> emit) {
    try {
      final updatedWorkEntry = state.workEntry.copyWith(
        timestamp: DateTime(
          event.date.year,
          event.date.month,
          event.date.day,
          state.workEntry.timestamp.hour,
          state.workEntry.timestamp.minute,
        ),
      );
      emit(EditWorkEntryUpdated(updatedWorkEntry));
    } catch (e) {
      logger.e(
          'Errore durante l\'aggiornamento della data della voce di lavoro',
          error: e);
      emit(EditWorkEntryError(state.workEntry,
          'Errore durante l\'aggiornamento della data della voce di lavoro: ${e.toString()}. Si prega di verificare la data selezionata e riprovare.'));
    }
  }

  /// Gestore dell'evento `UpdateTime`.
  /// Aggiorna l'ora della voce di lavoro nello stato corrente.
  void _onUpdateTime(UpdateTime event, Emitter<EditWorkEntryState> emit) {
    try {
      final updatedWorkEntry = state.workEntry.copyWith(
        timestamp: DateTime(
          state.workEntry.timestamp.year,
          state.workEntry.timestamp.month,
          state.workEntry.timestamp.day,
          event.time.hour,
          event.time.minute,
        ),
      );
      emit(EditWorkEntryUpdated(updatedWorkEntry));
    } catch (e) {
      logger.e('Errore durante l\'aggiornamento dell\'ora della voce di lavoro',
          error: e);
      emit(EditWorkEntryError(state.workEntry,
          'Errore durante l\'aggiornamento dell\'ora della voce di lavoro: ${e.toString()}. Si prega di verificare l\'ora selezionata e riprovare.'));
    }
  }
}

```

./lib/domain/blocs/edit_work_entry/edit_work_entry_event.dart:
```
part of 'edit_work_entry_bloc.dart';

/// Classe astratta che rappresenta un evento del `EditWorkEntryBloc`.
abstract class EditWorkEntryEvent extends Equatable {
  const EditWorkEntryEvent();
}

/// Evento per aggiornare la data della voce di lavoro.
class UpdateDate extends EditWorkEntryEvent {
  final DateTime date;

  const UpdateDate(this.date);

  @override
  List<Object> get props => [date];
}

/// Evento per aggiornare l'ora della voce di lavoro.
class UpdateTime extends EditWorkEntryEvent {
  /// La nuova ora della voce di lavoro.
  final TimeOfDay time;

  const UpdateTime(this.time);

  @override
  List<Object> get props => [time];
}

```

./lib/domain/blocs/edit_work_entry/edit_work_entry_state.dart:
```
part of 'edit_work_entry_bloc.dart';

/// Classe astratta che rappresenta uno stato del `EditWorkEntryBloc`.
abstract class EditWorkEntryState extends Equatable {
  /// La voce di lavoro corrente.
  final WorkEntry workEntry;

  const EditWorkEntryState(this.workEntry);

  @override
  List<Object> get props => [workEntry];
}

/// Stato iniziale del `EditWorkEntryBloc`.
class EditWorkEntryInitial extends EditWorkEntryState {
  const EditWorkEntryInitial(super.workEntry);
}

/// Stato che rappresenta una voce di lavoro aggiornata.
class EditWorkEntryUpdated extends EditWorkEntryState {
  const EditWorkEntryUpdated(super.workEntry);
}

class EditWorkEntryError extends EditWorkEntryState {
  /// Il messaggio di errore.
  final String errorMessage;

  const EditWorkEntryError(super.workEntry, this.errorMessage);

  @override
  List<Object> get props => [workEntry, errorMessage];
}

```

./lib/domain/entities/work_entry.dart:
```
import 'package:equatable/equatable.dart';

/// La classe `WorkEntry` rappresenta una voce di lavoro.
class WorkEntry extends Equatable {
  /// L'ID univoco della voce di lavoro (può essere null per le nuove voci).
  final int? id;

  /// Il timestamp della voce di lavoro.
  final DateTime timestamp;

  /// Un flag che indica se la voce è un'entrata o un'uscita.
  final bool isEntry;

  /// La data della voce di lavoro (senza l'ora).
  final DateTime day;

  /// Costruttore della classe `WorkEntry`.
  WorkEntry({
    this.id,
    required this.timestamp,
    required this.isEntry,
  }) : day = DateTime(timestamp.year, timestamp.month, timestamp.day);

  /// Crea una copia della voce di lavoro con i valori specificati.
  WorkEntry copyWith({
    int? id,
    DateTime? timestamp,
    bool? isEntry,
  }) {
    return WorkEntry(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      isEntry: isEntry ?? this.isEntry,
    );
  }

  @override
  List<Object?> get props => [id, timestamp, isEntry, day];
}

```

./lib/app.dart:
```
import 'package:flutter/material.dart';
import 'package:timetrailblazer/presentation/screens/home_page.dart';
import 'package:timetrailblazer/presentation/screens/work_entries_screen.dart';
import 'package:timetrailblazer/presentation/screens/work_stats_screen.dart';

/// La classe principale dell'applicazione che rappresenta il punto di ingresso dell'app.
/// Estende la classe `StatelessWidget` di Flutter, che indica che questo widget non ha uno stato mutabile.
class App extends StatelessWidget {
  /// Il costruttore della classe `App`.
  /// Accetta una chiave opzionale `key` che viene passata al costruttore della superclasse `StatelessWidget`.
  const App({super.key});

  /// Il metodo `build` è un override del metodo della superclasse `StatelessWidget`.
  /// Viene chiamato quando il widget deve essere renderizzato.
  /// Accetta un parametro `context` che rappresenta la posizione del widget nell'albero dei widget.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title:
          'timetrailblazer', // Il titolo dell'applicazione, utilizzato per scopi di accessibilità e indicizzazione
      theme: ThemeData(
        primarySwatch: Colors
            .blue, // Il colore primario del tema dell'app, utilizzato per elementi come la AppBar
      ),
      initialRoute:
          '/', // La rotta iniziale dell'applicazione, in questo caso la HomePage
      routes: {
        // Un oggetto `Map` che definisce le rotte dell'applicazione e i corrispondenti widget da visualizzare
        '/': (context) =>
            const HomePage(), // La rotta per la HomePage, che viene visualizzata quando l'app viene avviata
        '/work_entries': (context) =>
            const WorkEntriesScreen(), // La rotta per la WorkEntriesScreen, che mostra le voci di lavoro registrate
        '/work_stats': (context) =>
            const WorkStatsScreen(), // La rotta per la WorkStatsScreen, che mostra le statistiche di lavoro
      },
    );
  }
}

```

./lib/presentation/widgets/weekly_calendar.dart:
```
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:timetrailblazer/domain/entities/work_entry.dart';
import 'package:timetrailblazer/presentation/screens/edit_work_entry_screen.dart';

/// Il widget `WeeklyCalendar` visualizza le voci di lavoro in un calendario.
class WeeklyCalendar extends StatefulWidget {
  final Map<DateTime, List<WorkEntry>> entriesGroupedByDay;
  final Function(WorkEntry, int, DateTime) onEntryDeleted;
  final Function(WorkEntry) onEntryModified;
  final ScrollController scrollController;
  final DateTime startDate;
  final DateTime endDate;

  const WeeklyCalendar({
    super.key,
    required this.entriesGroupedByDay,
    required this.onEntryDeleted,
    required this.onEntryModified,
    required this.scrollController,
    required this.startDate,
    required this.endDate,
  });

  @override
  State<WeeklyCalendar> createState() => _WeeklyCalendarState();
}

class _WeeklyCalendarState extends State<WeeklyCalendar> {
  @override
  Widget build(BuildContext context) {
    final startDate = widget.startDate;
    final endDate = widget.endDate;
    final daysCount = endDate.difference(startDate).inDays + 1;

    // Utilizza `ListView.builder` per generare le righe del calendario
    // Ogni riga rappresenta un giorno nel range di date specificato
    return ListView.builder(
      controller: widget.scrollController,
      itemCount: daysCount,
      shrinkWrap: true,
      itemBuilder: (context, index) {
        final day = DateTime(
          startDate.year,
          startDate.month,
          startDate.day + index,
        );
        final entriesForDay = widget.entriesGroupedByDay[day] ?? [];
        return _buildDayRow(context, day, entriesForDay);
      },
    );
  }

  /// Costruisce una riga per un giorno nel calendario.
  /// 
  /// Parametri:
  ///   - `context`: il contesto del widget.
  ///   - `day`: la data del giorno.
  ///   - `entries`: le voci di lavoro per il giorno specificato.
  Widget _buildDayRow(
      BuildContext context, DateTime day, List<WorkEntry> entries) {
    final formattedDate = DateFormat('EEE, dd MMM yyyy', 'it_IT').format(day);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          formattedDate,
          style: const TextStyle(
            fontWeight: FontWeight.bold,
            fontSize: 16,
          ),
        ),
        const SizedBox(height: 8),
        ...entries.map((entry) {
          final entryColor = entry.isEntry ? Colors.green : Colors.red;

          return GestureDetector(
            onHorizontalDragEnd: (details) {
              if (details.primaryVelocity != null) {
                if (details.primaryVelocity! < 0) {
                  // Swipe da destra a sinistra per eliminare la voce di lavoro
                  widget.onEntryDeleted(entry, entry.id!, entry.day);
                } else if (details.primaryVelocity! > 0) {
                  // Swipe da sinistra a destra per modificare la voce di lavoro
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) =>
                          EditWorkEntryScreen(workEntry: entry),
                    ),
                  ).then((updatedEntry) {
                    if (updatedEntry != null) {
                      widget.onEntryModified(updatedEntry);
                    }
                  });
                }
              }
            },
            child: ListTile(
              title: Text(
                '${entry.isEntry ? 'Entrata' : 'Uscita'}: ${DateFormat('HH:mm').format(entry.timestamp)}',
                style: TextStyle(color: entryColor),
              ),
              trailing: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  IconButton(
                    icon: const Icon(Icons.edit),
                    onPressed: () {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) =>
                              EditWorkEntryScreen(workEntry: entry),
                        ),
                      ).then((updatedEntry) {
                        if (updatedEntry != null) {
                          widget.onEntryModified(updatedEntry);
                        }
                      });
                    },
                  ),
                  IconButton(
                    icon: const Icon(Icons.delete),
                    onPressed: () {
                      widget.onEntryDeleted(entry, entry.id!, entry.day);
                    },
                  ),
                ],
              ),
            ),
          );
        }),
        const SizedBox(height: 16),
      ],
    );
  }
}

```

./lib/presentation/widgets/work_stats_list_item.dart:
```
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

/// Il widget `WorkStatsListItem` rappresenta un elemento della lista delle statistiche di lavoro.
class WorkStatsListItem extends StatelessWidget {
  /// La data delle statistiche di lavoro.
  final String date;

  /// La durata totale del lavoro per la data specificata.
  final Duration duration;

  const WorkStatsListItem({
    super.key,
    required this.date,
    required this.duration,
  });

  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: const Icon(Icons.work),
      title: Text(DateFormat('dd/MM/yyyy').format(DateTime.parse(date))),
      subtitle: Text(
        'Tempo di lavoro: ${duration.inHours} ore ${duration.inMinutes.remainder(60)} minuti',
      ),
    );
  }
}

```

./lib/presentation/widgets/work_button.dart:
```
import 'package:flutter/material.dart';
import 'package:timetrailblazer/constants.dart';

/// Il widget `WorkButton` rappresenta un pulsante personalizzato per le azioni di entrata e uscita.
class WorkButton extends StatelessWidget {
  /// L'etichetta del pulsante.
  final String label;

  /// La funzione di callback da chiamare quando il pulsante viene premuto.
  final VoidCallback? onPressed;

  /// La larghezza del pulsante.
  final double? width;

  const WorkButton({
    super.key,
    required this.label,
    this.onPressed,
    this.width,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: width,
      child: ElevatedButton(
        onPressed: onPressed,
        style: ElevatedButton.styleFrom(
          foregroundColor: primaryColor,
          backgroundColor: secondaryColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(30),
          ),
          padding: const EdgeInsets.symmetric(
            vertical: buttonPaddingV,
            horizontal: buttonPaddingH,
          ),
          elevation: buttonElevation,
          shadowColor: shadowColor.withOpacity(0.2),
        ),
        child: Text(
          label,
          style: const TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }
}

```

./lib/presentation/widgets/date_range_picker.dart:
```
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

/// Il widget `DateRangePicker` consente all'utente di selezionare un intervallo di date.
class DateRangePicker extends StatelessWidget {
  /// La data di inizio dell'intervallo selezionato.
  final DateTime startDate;

  /// La data di fine dell'intervallo selezionato.
  final DateTime endDate;

  /// La funzione di callback da chiamare quando la data di inizio viene modificata.
  final Function(DateTime) onStartDateChanged;

  /// La funzione di callback da chiamare quando la data di fine viene modificata.
  final Function(DateTime) onEndDateChanged;

  /// La funzione di callback da chiamare quando viene premuto il pulsante "Mese corrente".
  final VoidCallback onCurrentMonthPressed;

  const DateRangePicker({
    super.key,
    required this.startDate,
    required this.endDate,
    required this.onStartDateChanged,
    required this.onEndDateChanged,
    required this.onCurrentMonthPressed,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        Flexible(
          child: ElevatedButton(
            onPressed: () => _selectDate(context, true),
            child: Text('Dal: ${DateFormat('dd/MM/yyyy').format(startDate)}'),
          ),
        ),
        Flexible(
          child: ElevatedButton(
            onPressed: () => _selectDate(context, false),
            child: Text('Al: ${DateFormat('dd/MM/yyyy').format(endDate)}'),
          ),
        ),
        Flexible(
          child: ElevatedButton(
            onPressed: onCurrentMonthPressed,
            child: const Text('Mese corrente'),
          ),
        ),
      ],
    );
  }

  /// Mostra un selettore di data e chiama la funzione di callback appropriata quando una data viene selezionata.
  ///
  /// Parametri:
  ///   - `context`: il contesto del widget.
  ///   - `isStartDate`: un flag che indica se la data selezionata è la data di inizio o di fine.
  Future<void> _selectDate(BuildContext context, bool isStartDate) async {
    final DateTime? pickedDate = await showDatePicker(
      context: context,
      initialDate: isStartDate ? startDate : endDate,
      firstDate: isStartDate ? DateTime(2000) : startDate,
      lastDate: isStartDate ? endDate : DateTime(2100),
    );

    if (pickedDate != null) {
      isStartDate
          ? onStartDateChanged(pickedDate)
          : onEndDateChanged(pickedDate);
    }
  }
}

```

./lib/presentation/screens/home_page.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:timetrailblazer/constants.dart';
import 'package:timetrailblazer/data/dependencies/repositories/work_entries_repository.dart';
import 'package:timetrailblazer/domain/blocs/home_page/home_bloc.dart';
import 'package:timetrailblazer/domain/blocs/work_entries/work_entries_bloc.dart';
import 'package:timetrailblazer/domain/entities/work_entry.dart';
import 'package:timetrailblazer/presentation/widgets/work_button.dart';
import 'package:timetrailblazer/utils/error_handler.dart';
import 'package:timetrailblazer/utils/logger.dart';

/// La schermata principale dell'applicazione.
class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  HomePageState createState() => HomePageState();
}

/// Lo stato della schermata principale.
class HomePageState extends State<HomePage> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(homeTitle),
      ),
      body: SafeArea(
        child: BlocBuilder<HomeBloc, HomeState>(
          builder: (context, state) {
            return FutureBuilder<WorkEntry?>(
              future:
                  context.read<WorkEntriesRepositoryImpl>().getLastWorkEntry(),
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting) {
                  // Mostra un indicatore di caricamento mentre il FutureBuilder sta recuperando i dati
                  return const Center(child: CircularProgressIndicator());
                }
                if (snapshot.hasError) {
                  // Gestisci gli errori del FutureBuilder
                  return Center(child: Text('Errore: ${snapshot.error}'));
                }
                final lastWorkEntry = snapshot.data;

                final isEntryAllowed =
                    lastWorkEntry == null || !lastWorkEntry.isEntry;

                return LayoutBuilder(
                  builder: (BuildContext context, BoxConstraints constraints) {
                    final bool isLandscape =
                        constraints.maxWidth > constraints.maxHeight;
                    final double buttonWidth =
                        constraints.maxWidth * (isLandscape ? 0.4 : 0.8);

                    return Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        crossAxisAlignment: CrossAxisAlignment.stretch,
                        children: [
                          SizedBox(height: constraints.maxHeight * 0.1),
                          Flexible(
                            child: WorkButton(
                              label: 'Entrata',
                              onPressed: isEntryAllowed
                                  ? () {
                                      _registerEntry(context, true);
                                      context
                                          .read<HomeBloc>()
                                          .add(EntryButtonPressed());
                                    }
                                  : null,
                              width: buttonWidth,
                            ),
                          ),
                          const SizedBox(height: 16),
                          Flexible(
                            child: WorkButton(
                              label: 'Uscita',
                              onPressed: !isEntryAllowed
                                  ? () {
                                      _registerEntry(context, false);
                                      context
                                          .read<HomeBloc>()
                                          .add(ExitButtonPressed());
                                    }
                                  : null,
                              width: buttonWidth,
                            ),
                          ),
                          const SizedBox(height: 32),
                          ElevatedButton(
                            onPressed: () {
                              Navigator.pushNamed(context, '/work_entries')
                                  .then((_) => _refreshWorkEntries());
                            },
                            child: const Text('Visualizza registrazioni'),
                          ),
                        ],
                      ),
                    );
                  },
                );
              },
            );
          },
        ),
      ),
    );
  }

  /// Registra una nuova voce di lavoro (entrata o uscita) nel database.
  /// 
  /// Parametri:
  ///   - `context`: il contesto del widget.
  ///   - `isEntry`: un flag che indica se la voce è un'entrata o un'uscita.
  void _registerEntry(BuildContext context, bool isEntry) {
    final now = DateTime.now();
    final workEntriesBloc = context.read<WorkEntriesBloc>();

    // Validazione dei dati
    if (now.isBefore(DateTime.now().subtract(const Duration(days: 1)))) {
      // Mostra un messaggio di errore se la data è precedente a ieri
      ErrorHandler.showErrorDialog(
        'Data non valida',
        'Non è possibile registrare voci di lavoro per date precedenti a ieri. Per favore, seleziona una data valida.',
      );
      return;
    }

    final entry = WorkEntry(
      timestamp: now,
      isEntry: isEntry,
    );

    try {
      // Controlla se i dati sono validi prima di chiamare il metodo del repository
      if (entry.timestamp
          .isBefore(DateTime.now().subtract(const Duration(days: 1)))) {
        throw Exception('Data non valida');
      }
      workEntriesBloc.add(AddWorkEntry(entry));
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(isEntry ? entryRegistered : exitRegistered)),
      );
    } catch (e) {
      logger.e('Errore durante la registrazione della voce di lavoro',
          error: e);
      ErrorHandler.showErrorDialog('Errore di registrazione',
          'Errore durante la registrazione della voce di lavoro: ${e.toString()}. Si prega di verificare i dati inseriti e riprovare. Se il problema persiste, contattare l\'assistenza.');
    }
  }

  /// Aggiorna le voci di lavoro visualizzate nella schermata WorkEntriesScreen.
  void _refreshWorkEntries() {
    final workEntriesBloc = context.read<WorkEntriesBloc>();
    workEntriesBloc.add(
      FetchWorkEntries(
        startDate: DateTime.now().subtract(const Duration(days: 1)),
        endDate: DateTime.now(),
      ),
    );
  }
}

```

./lib/presentation/screens/edit_work_entry_screen.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:intl/intl.dart';
import 'package:timetrailblazer/domain/blocs/edit_work_entry/edit_work_entry_bloc.dart';
import 'package:timetrailblazer/domain/blocs/work_entries/work_entries_bloc.dart';
import 'package:timetrailblazer/domain/entities/work_entry.dart';
import 'package:timetrailblazer/utils/error_handler.dart';
import 'package:timetrailblazer/utils/logger.dart';

/// Schermata per la modifica di una voce di lavoro.
///
/// Questa schermata consente all'utente di modificare i dettagli di una voce di lavoro esistente,
/// come la data e l'ora. Le modifiche vengono salvate quando l'utente preme il pulsante "Salva".
///
/// Esempio di utilizzo:
///
/// Navigator.push(
///   context,
///   MaterialPageRoute(
///     builder: (context) => EditWorkEntryScreen(workEntry: entry),
///   ),
/// );
class EditWorkEntryScreen extends StatelessWidget {
  /// La voce di lavoro da modificare.
  final WorkEntry workEntry;

  /// Costruttore della schermata di modifica della voce di lavoro.
  /// 
  /// Parametri:
  ///   - `workEntry`: la voce di lavoro da modificare.
  const EditWorkEntryScreen({super.key, required this.workEntry});

  @override
  Widget build(BuildContext context) {
    // Il `BlocProvider` viene utilizzato per fornire il `EditWorkEntryBloc` alla schermata
    // Viene passata la voce di lavoro iniziale al costruttore del bloc
    return BlocProvider(
      create: (context) => EditWorkEntryBloc(workEntry),
      child: const EditWorkEntryView(),
    );
  }
}

/// Vista della schermata di modifica di una voce di lavoro.
class EditWorkEntryView extends StatelessWidget {
  const EditWorkEntryView({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Modifica registrazione'),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Mostra la data e l'ora attuali della voce di lavoro e consente di modificarle.
            BlocBuilder<EditWorkEntryBloc, EditWorkEntryState>(
              builder: (context, state) {
                final workEntry = state.workEntry;
                return LayoutBuilder(
                  builder: (BuildContext context, BoxConstraints constraints) {
                    final double fontSize =
                        constraints.maxWidth < 600 ? 16 : 18;
                    return Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Data: ${DateFormat('dd/MM/yyyy').format(workEntry.timestamp)}',
                          style: TextStyle(fontSize: fontSize),
                        ),
                        const SizedBox(height: 8),
                        ElevatedButton(
                          onPressed: () => _selectDate(context),
                          child: const Text('Seleziona data'),
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'Ora: ${TimeOfDay.fromDateTime(workEntry.timestamp).format(context)}',
                          style: TextStyle(fontSize: fontSize),
                        ),
                        const SizedBox(height: 8),
                        ElevatedButton(
                          onPressed: () => _selectTime(context),
                          child: const Text('Seleziona ora'),
                        ),
                      ],
                    );
                  },
                );
              },
            ),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: () => _updateWorkEntry(context),
              child: const Text('Salva'),
            ),
          ],
        ),
      ),
    );
  }

  /// Mostra un selettore di data e aggiorna la data della voce di lavoro.
  /// 
  /// Parametri:
  ///   - `context`: il contesto del widget.
  Future<void> _selectDate(BuildContext context) async {
    final editWorkEntryBloc = context.read<EditWorkEntryBloc>();
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: editWorkEntryBloc.state.workEntry.timestamp,
      firstDate: DateTime(2000),
      lastDate: DateTime(2100),
    );

    // Validazione dei dati
    if (picked != null) {
      if (picked.isBefore(DateTime.now().subtract(const Duration(days: 1)))) {
        // Mostra un messaggio di errore se la data selezionata è precedente a ieri
        ErrorHandler.showErrorDialog(
          'Data non valida',
          'Non è possibile selezionare una data precedente a ieri. Per favore, seleziona una data valida.',
        );
        return;
      }
      editWorkEntryBloc.add(UpdateDate(picked));
    }
  }

  /// Mostra un selettore di ora e aggiorna l'ora della voce di lavoro.
  /// 
  /// Parametri:
  ///   - `context`: il contesto del widget.
  Future<void> _selectTime(BuildContext context) async {
    final editWorkEntryBloc = context.read<EditWorkEntryBloc>();
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime:
          TimeOfDay.fromDateTime(editWorkEntryBloc.state.workEntry.timestamp),
    );

    // Validazione dei dati
    if (picked != null) {
      final now = DateTime.now();
      final selectedDateTime = DateTime(
        editWorkEntryBloc.state.workEntry.timestamp.year,
        editWorkEntryBloc.state.workEntry.timestamp.month,
        editWorkEntryBloc.state.workEntry.timestamp.day,
        picked.hour,
        picked.minute,
      );

      if (selectedDateTime.isAfter(now)) {
        // Mostra un messaggio di errore se l'orario selezionato è nel futuro
        ErrorHandler.showErrorDialog(
          'Orario non valido',
          'Non è possibile selezionare un orario futuro. Per favore, seleziona un orario valido.',
        );
        return;
      }
      editWorkEntryBloc.add(UpdateTime(picked));
    }
  }

  /// Aggiorna la voce di lavoro nel database e torna alla schermata precedente.
  /// 
  /// Parametri:
  ///   - `context`: il contesto del widget.
  Future<void> _updateWorkEntry(BuildContext context) async {
    final editWorkEntryBloc = context.read<EditWorkEntryBloc>();
    final workEntry = editWorkEntryBloc.state.workEntry;
    try {
      // Controlla se i dati sono validi prima di chiamare il metodo del repository
      if (workEntry.timestamp
          .isBefore(DateTime.now().subtract(const Duration(days: 1)))) {
        throw Exception('Data non valida');
      }
      if (workEntry.timestamp.isAfter(DateTime.now())) {
        throw Exception('Orario non valido');
      }
      context.read<WorkEntriesBloc>().add(UpdateWorkEntry(workEntry));
      Navigator.pop(context, workEntry);
    } catch (e) {
      logger.e('Errore durante l\'aggiornamento della voce di lavoro',
          error: e);
      ErrorHandler.showErrorDialog('Errore di aggiornamento',
          'Errore durante l\'aggiornamento della voce di lavoro: ${e.toString()}. Si prega di verificare i dati inseriti e riprovare. Se il problema persiste, contattare l\'assistenza.');
    }
  }
}

```

./lib/presentation/screens/work_entries_screen.dart:
```
import 'dart:io';

import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:timetrailblazer/constants.dart';
import 'package:timetrailblazer/data/dependencies/repositories/work_entries_repository.dart';
import 'package:timetrailblazer/domain/blocs/home_page/home_bloc.dart';
import 'package:timetrailblazer/domain/blocs/work_entries/work_entries_bloc.dart';
import 'package:timetrailblazer/presentation/widgets/date_range_picker.dart';
import 'package:timetrailblazer/presentation/widgets/weekly_calendar.dart';
import 'package:timetrailblazer/utils/error_handler.dart';
import 'package:timetrailblazer/utils/logger.dart';

/// La schermata che mostra le voci di lavoro registrate.
class WorkEntriesScreen extends StatefulWidget {
  const WorkEntriesScreen({super.key});

  @override
  WorkEntriesScreenState createState() => WorkEntriesScreenState();
}

/// Lo stato della schermata delle voci di lavoro.
class WorkEntriesScreenState extends State<WorkEntriesScreen> {
  final ScrollController _scrollController = ScrollController();
  DateTime _startDate = DateTime(DateTime.now().year, DateTime.now().month, 1);
  DateTime _endDate =
      DateTime(DateTime.now().year, DateTime.now().month + 1, 0);
  late WorkEntriesRepositoryImpl _workEntriesRepository;
  late WorkEntriesBloc _workEntriesBloc;
  late HomeBloc _homeBloc;

  @override
  void initState() {
    super.initState();
    _workEntriesBloc = context.read<WorkEntriesBloc>();
    _homeBloc = context.read<HomeBloc>();
    _workEntriesRepository = context.read<WorkEntriesRepositoryImpl>();
    _loadSelectedDates();
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  /// Recupera le voci di lavoro dal database.
  void _fetchWorkEntries() {
    _workEntriesBloc.add(
      FetchWorkEntries(
        startDate: _startDate,
        endDate: _endDate.add(const Duration(days: 1)),
      ),
    );
  }

  /// Reimposta il database eliminando tutte le voci di lavoro.
  Future<void> _resetDatabase() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text(confirmResetTitle),
        content: const Text(confirmResetMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text(cancelButtonText),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text(confirmButtonText),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      _workEntriesBloc.add(DeleteAllWorkEntries(_startDate, _endDate));
      _homeBloc.add(ExitButtonPressed());
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(workEntriesTitle),
        actions: [
          IconButton(
            icon: const Icon(Icons.file_upload),
            onPressed: _importFromCsv,
          ),
          IconButton(
            icon: const Icon(Icons.file_download),
            onPressed: _handleExportToCsv,
          ),
          IconButton(
            icon: const Icon(Icons.delete_forever, color: Colors.red),
            onPressed: _resetDatabase,
          ),
        ],
      ),
      body: Column(
        children: [
          const Spacer(
            flex: 1,
          ),
          Flexible(
            flex: 3,
            child: DateRangePicker(
              startDate: _startDate,
              endDate: _endDate,
              onStartDateChanged: (date) {
                setState(() => _startDate = date);
                _addUpdateDateRangeEvent();
              },
              onEndDateChanged: (date) {
                setState(() => _endDate = date);
                _addUpdateDateRangeEvent();
              },
              onCurrentMonthPressed: _resetToCurrentMonth,
            ),
          ),
          const Spacer(
            flex: 1,
          ),
          Flexible(
            flex: 3,
            child: ElevatedButton(
              onPressed: () {
                Navigator.pushNamed(context, '/work_stats');
              },
              child: const Text('Statistiche di lavoro'),
            ),
          ),
          const Spacer(
            flex: 1,
          ),
          Expanded(
            flex: 20,
            child: BlocBuilder<WorkEntriesBloc, WorkEntriesState>(
              builder: (context, state) {
                if (state is WorkEntriesLoading) {
                  return const Center(child: CircularProgressIndicator());
                }
                if (state is WorkEntriesError) {
                  ErrorHandler.showErrorNotification(
                    'Errore durante il caricamento delle voci di lavoro: ${state.message}. Si prega di riprovare più tardi o verificare la connessione di rete.',
                  );
                  return Container();
                }
                if (state is WorkEntriesLoaded) {
                  return WeeklyCalendar(
                    entriesGroupedByDay: state.entriesGroupedByDay,
                    onEntryDeleted: (entry, entryId, day) {
                      _workEntriesBloc.add(DeleteWorkEntry(entryId, day));
                      if (entry.isEntry) {
                        _homeBloc.add(ExitButtonPressed());
                      } else {
                        _homeBloc.add(EntryButtonPressed());
                      }
                    },
                    onEntryModified: (entry) {
                      _workEntriesBloc.add(UpdateWorkEntry(entry));
                    },
                    scrollController: _scrollController,
                    startDate: _startDate,
                    endDate: _endDate,
                  );
                }
                return WeeklyCalendar(
                  entriesGroupedByDay: const {},
                  onEntryDeleted: (_, __, ___) {},
                  onEntryModified: (_) {},
                  scrollController: _scrollController,
                  startDate: _startDate,
                  endDate: _endDate,
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  /// Aggiunge un evento `UpdateDateRange` al BLoC, recupera le voci di lavoro e salva le date selezionate.
  void _addUpdateDateRangeEvent() {
    _workEntriesBloc.add(UpdateDateRange(_startDate, _endDate));
    _fetchWorkEntries();
    _saveSelectedDates();
  }

  /// Carica le date selezionate da `shared_preferences` e le passa al BLoC.
  Future<void> _loadSelectedDates() async {
    final prefs = await SharedPreferences.getInstance();
    final startDateMillis = prefs.getInt('startDate');
    final endDateMillis = prefs.getInt('endDate');

    if (startDateMillis != null && endDateMillis != null) {
      _startDate = DateTime.fromMillisecondsSinceEpoch(startDateMillis);
      _endDate = DateTime.fromMillisecondsSinceEpoch(endDateMillis);
      _workEntriesBloc.add(UpdateDateRange(_startDate, _endDate));
    }

    _fetchWorkEntries();
  }

  /// Salva le date selezionate in `shared_preferences`.
  Future<void> _saveSelectedDates() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt('startDate', _startDate.millisecondsSinceEpoch);
    await prefs.setInt('endDate', _endDate.millisecondsSinceEpoch);
  }

  /// Ripristina le date al mese corrente e aggiorna il BLoC.
  void _resetToCurrentMonth() {
    _startDate = DateTime(DateTime.now().year, DateTime.now().month, 1);
    _endDate = DateTime(DateTime.now().year, DateTime.now().month + 1, 0);
    _addUpdateDateRangeEvent();
  }

  /// Esporta le voci di lavoro in un file CSV.
  Future<void> _handleExportToCsv() async {
    final state = _workEntriesBloc.state;
    if (state is WorkEntriesLoaded) {
      final entries = state.entries;
      try {
        final path = await context
            .read<WorkEntriesRepositoryImpl>()
            .exportToCsv(entries);
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('$csvExportSuccess $path')),
          );
        }
      } catch (e) {
        logger.e(
            'Errore durante l\'esportazione delle voci di lavoro in formato CSV',
            error: e);
        ErrorHandler.showErrorDialog('Errore di esportazione',
            'Errore durante l\'esportazione delle voci di lavoro in formato CSV: ${e.toString()}. Si prega di verificare che ci sia spazio sufficiente sul dispositivo e che l\'applicazione abbia i permessi necessari per scrivere i file.');
      }
    }
  }

  /// Importa le voci di lavoro da un file CSV.
  Future<void> _importFromCsv() async {
    final result = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: ['csv'],
    );

    // Validazione dei dati
    if (result != null && result.files.isNotEmpty) {
      final path = result.files.first.path;
      if (path != null) {
        try {
          // Controlla se il file CSV esiste e ha un formato valido prima di chiamare il metodo del repository
          final file = File(path);
          if (!await file.exists()) {
            throw Exception('File CSV non trovato');
          }
          final csvString = await file.readAsString();
          if (csvString.isEmpty) {
            throw Exception('File CSV vuoto');
          }

          await _workEntriesRepository.importFromCsv(path);
          bool result =
              (await _workEntriesRepository.getLastWorkEntry())!.isEntry;
          if (!result) {
            _homeBloc.add(ExitButtonPressed());
          } else {
            _homeBloc.add(EntryButtonPressed());
          }

          _workEntriesBloc.add(FetchWorkEntries(
            startDate: _startDate,
            endDate: _endDate.add(const Duration(days: 1)),
          ));
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text('Importazione CSV completata')),
            );
          }
        } catch (e) {
          logger.e('Errore durante l\'importazione CSV', error: e);

          ErrorHandler.showErrorSnackBar(
            'Errore durante l\'importazione CSV: ${e.toString()}',
          );
        }
      } else {
        // Mostra un messaggio di errore se il percorso del file è nullo
        ErrorHandler.showErrorSnackBar(
          'Errore durante la selezione del file CSV. Per favore, riprova e seleziona un file CSV valido.',
        );
      }
    } else {
      // Mostra un messaggio di errore se nessun file è stato selezionato
      ErrorHandler.showErrorSnackBar(
        'Nessun file CSV selezionato. Per favore, seleziona un file CSV per l\'importazione.',
      );
    }
  }
}

```

./lib/presentation/screens/work_stats_screen.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:intl/intl.dart';
import 'package:timetrailblazer/data/dependencies/repositories/work_entries_repository.dart';
import 'package:timetrailblazer/presentation/widgets/work_stats_list_item.dart';
import 'package:timetrailblazer/utils/error_handler.dart';
import 'package:timetrailblazer/utils/logger.dart';

/// La schermata che mostra le statistiche di lavoro.
class WorkStatsScreen extends StatelessWidget {
  const WorkStatsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Statistiche di lavoro'),
      ),
      // Utilizza `FutureBuilder` per gestire il caricamento asincrono delle statistiche dal repository
      body: FutureBuilder<Map<DateTime, Duration>>(
        future:
            context.read<WorkEntriesRepositoryImpl>().calculateWorkTimeMap(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          } else if (snapshot.hasError) {
            logger.e('Errore durante il caricamento delle statistiche',
                error: snapshot.error);
            ErrorHandler.showErrorNotification(
              'Errore durante il caricamento delle statistiche: ${snapshot.error}. Si prega di riprovare più tardi.',
            );
            return Container();
          } else {
            final workTimeMap = snapshot.data!;
            final workDates = workTimeMap.keys.toList();
            workDates.sort((a, b) => b.compareTo(a));

            return ListView.separated(
              itemCount: workDates.length,
              itemBuilder: (context, index) {
                final workDate = workDates[index];
                final workDuration = workTimeMap[workDate]!;

                // Mostra le statistiche di lavoro giornaliere utilizzando il widget `WorkStatsListItem`
                return WorkStatsListItem(
                  date: DateFormat('yyyy-MM-dd').format(workDate),
                  duration: workDuration,
                );
              },
              separatorBuilder: (context, index) => const Divider(),
            );
          }
        },
      ),
    );
  }
}

```

./lib/data/database_helper.dart:
```
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:timetrailblazer/data/models/work_entry_dto.dart';
import 'package:timetrailblazer/utils/logger.dart';

/// La classe `DatabaseHelper` gestisce l'accesso al database SQLite dell'applicazione.
class DatabaseHelper {
  static const _databaseName = 'work_entries.db'; // Il nome del database
  static const _databaseVersion = 1; // La versione del database
  static const table = 'work_entries'; // Il nome della tabella nel database

  static Database? _database; // L'istanza del database

  /// Inizializza il database chiamando il metodo `database`.
  Future<void> initializeDatabase() async {
    await database;
  }

  /// Ottiene l'istanza del database. Se il database non esiste, viene creato.
  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  /// Inizializza il database creando la tabella `work_entries` se non esiste.
  Future<Database> _initDatabase() async {
    final documentsDirectory = await getDatabasesPath();
    final path = join(documentsDirectory, _databaseName);
    return await openDatabase(
      path,
      version: _databaseVersion,
      onCreate: _onCreate,
    );
  }

  /// Crea la tabella `work_entries` nel database.
  Future<void> _onCreate(Database db, int version) async {
    try {
      await db.execute('''
        CREATE TABLE $table(
          id INTEGER PRIMARY KEY,
          timestamp INTEGER,
          is_entry INTEGER,
          FOREIGN KEY (work_entry_id) REFERENCES work_entries (id) ON DELETE CASCADE
        )
      ''');
    } catch (e) {
      logger.e('Errore durante la creazione della tabella work_entries',
          error: e);
      throw Exception(
          'Errore durante la creazione della tabella work_entries: ${e.toString()}');
    }
  }

  /// Inserisce una nuova voce di lavoro nel database.
  Future<void> insertWorkEntry(WorkEntryDTO entry) async {
    final db = await database;
    try {
      await db.insert(
        table,
        entry.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    } catch (e) {
      logger.e(
          'Errore durante l\'inserimento della voce di lavoro nel database',
          error: e);
      throw Exception(
          'Errore durante l\'inserimento della voce di lavoro nel database: ${e.toString()}. Si prega di riprovare più tardi o contattare l\'assistenza se il problema persiste.');
    }
  }

  /// Recupera le voci di lavoro dal database in base all'intervallo di date specificato.
  Future<List<WorkEntryDTO>> getWorkEntries(
    DateTime startDate,
    DateTime endDate,
  ) async {
    final db = await database;
    try {
      final List<Map<String, dynamic>> maps = await db.query(
        table,
        where: 'timestamp >= ? AND timestamp <= ?',
        whereArgs: [
          startDate.millisecondsSinceEpoch,
          endDate.millisecondsSinceEpoch,
        ],
        orderBy: 'timestamp DESC',
      );
      return List.generate(maps.length, (i) => WorkEntryDTO.fromMap(maps[i]));
    } catch (e) {
      logger.e('Errore durante il recupero delle voci di lavoro dal database',
          error: e);
      throw Exception(
          'Errore durante il recupero delle voci di lavoro dal database: ${e.toString()}. Si prega di riprovare più tardi o contattare l\'assistenza se il problema persiste.');
    }
  }

  /// Elimina tutte le voci di lavoro dal database.
  Future<void> deleteAllWorkEntries() async {
    final db = await database;
    try {
      await db.delete(table);
    } catch (e) {
      logger.e(
          'Errore durante l\'eliminazione di tutte le voci di lavoro dal database',
          error: e);
      throw Exception(
          'Errore durante l\'eliminazione di tutte le voci di lavoro dal database: ${e.toString()}. Si prega di riprovare più tardi o contattare l\'assistenza se il problema persiste.');
    }
  }

  /// Elimina una specifica voce di lavoro dal database in base all'ID.
  Future<void> deleteWorkEntry(int entryId) async {
    final db = await database;
    try {
      await db.delete(
        table,
        where: 'id = ?',
        whereArgs: [entryId],
      );
    } catch (e) {
      logger.e(
          'Errore durante l\'eliminazione della voce di lavoro dal database',
          error: e);
      throw Exception(
          'Errore durante l\'eliminazione della voce di lavoro dal database: ${e.toString()}. Si prega di verificare l\'ID della voce di lavoro e riprovare. Se il problema persiste, contattare l\'assistenza.');
    }
  }

  /// Aggiorna una voce di lavoro nel database.
  Future<void> updateWorkEntry(WorkEntryDTO entry) async {
    final db = await database;
    try {
      await db.update(
        table,
        entry.toMap(),
        where: 'id = ?',
        whereArgs: [entry.id],
      );
    } catch (e) {
      logger.e(
          'Errore durante l\'aggiornamento della voce di lavoro nel database',
          error: e);
      throw Exception(
          'Errore durante l\'aggiornamento della voce di lavoro nel database: ${e.toString()}. Si prega di verificare i dati della voce di lavoro e riprovare. Se il problema persiste, contattare l\'assistenza.');
    }
  }

  /// Recupera l'ultima voce di lavoro inserita nel database.
  Future<WorkEntryDTO?> getLastWorkEntry() async {
    final db = await database;
    try {
      final List<Map<String, dynamic>> maps = await db.query(
        table,
        orderBy: 'timestamp DESC',
      );
      if (maps.isNotEmpty) {
        return WorkEntryDTO.fromMap(maps.first);
      }
      return null;
    } catch (e) {
      logger.e(
          'Errore durante il recupero dell\'ultima voce di lavoro dal database',
          error: e);
      throw Exception(
          'Errore durante il recupero dell\'ultima voce di lavoro dal database: ${e.toString()}. Si prega di riprovare più tardi o contattare l\'assistenza se il problema persiste.');
    }
  }
}

```

./lib/data/dependencies/providers/work_entries_provider.dart:
```
import 'package:timetrailblazer/data/database_helper.dart';
import 'package:timetrailblazer/data/models/work_entry_dto.dart';
import 'package:timetrailblazer/utils/logger.dart';

/// La classe `WorkEntriesProvider` fornisce i metodi per interagire con il database delle voci di lavoro.
class WorkEntriesProvider {
  final DatabaseHelper _databaseHelper;

  WorkEntriesProvider(this._databaseHelper);

  /// Inserisce una nuova voce di lavoro nel database.
  Future<void> insertWorkEntry(WorkEntryDTO entry) async {
    try {
      await _databaseHelper.insertWorkEntry(entry);
    } catch (e) {
      logger.e('Errore durante l\'inserimento della voce di lavoro', error: e);
      throw Exception(
          'Errore durante l\'inserimento della voce di lavoro: ${e.toString()}');
    }
  }

  /// Recupera le voci di lavoro dal database in base all'intervallo di date specificato.
  Future<List<WorkEntryDTO>> getWorkEntries(
    DateTime startDate,
    DateTime endDate,
  ) async {
    try {
      return await _databaseHelper.getWorkEntries(
        startDate,
        endDate,
      );
    } catch (e) {
      logger.e('Errore durante il recupero delle voci di lavoro', error: e);
      throw Exception(
          'Errore durante il recupero delle voci di lavoro: ${e.toString()}');
    }
  }

  /// Elimina tutte le voci di lavoro dal database.
  Future<void> deleteAllWorkEntries() async {
    try {
      await _databaseHelper.deleteAllWorkEntries();
    } catch (e) {
      logger.e('Errore durante l\'eliminazione di tutte le voci di lavoro',
          error: e);
      throw Exception(
          'Errore durante l\'eliminazione di tutte le voci di lavoro: ${e.toString()}');
    }
  }

  /// Elimina una specifica voce di lavoro dal database in base all'ID.
  Future<void> deleteWorkEntry(int entryId) async {
    try {
      await _databaseHelper.deleteWorkEntry(entryId);
    } catch (e) {
      logger.e('Errore durante l\'eliminazione della voce di lavoro', error: e);
      throw Exception(
          'Errore durante l\'eliminazione della voce di lavoro: ${e.toString()}');
    }
  }

  /// Aggiorna una voce di lavoro nel database.
  Future<void> updateWorkEntry(WorkEntryDTO entry) async {
    try {
      await _databaseHelper.updateWorkEntry(entry);
    } catch (e) {
      logger.e('Errore durante l\'aggiornamento della voce di lavoro',
          error: e);
      throw Exception(
          'Errore durante l\'aggiornamento della voce di lavoro: ${e.toString()}');
    }
  }

  /// Recupera l'ultima voce di lavoro inserita nel database.
  Future<WorkEntryDTO?> getLastWorkEntry() async {
    try {
      return await _databaseHelper.getLastWorkEntry();
    } catch (e) {
      logger.e('Errore durante il recupero dell\'ultima voce di lavoro',
          error: e);
      throw Exception(
          'Errore durante il recupero dell\'ultima voce di lavoro: ${e.toString()}');
    }
  }
}

```

./lib/data/dependencies/mappers/work_entry_mapper.dart:
```
import 'package:timetrailblazer/data/models/work_entry_dto.dart';
import 'package:timetrailblazer/domain/entities/work_entry.dart';
import 'package:timetrailblazer/utils/logger.dart';

/// La classe `WorkEntryMapper` mappa le entità `WorkEntry` in oggetti `WorkEntryDTO` e viceversa.
class WorkEntryMapper {
  /// Mappa un oggetto `WorkEntryDTO` in un'entità `WorkEntry`.
  WorkEntry fromDTO(WorkEntryDTO dto) {
    try {
      return WorkEntry(
        id: dto.id,
        timestamp: dto.timestamp,
        isEntry: dto.isEntry,
      );
    } catch (e) {
      logger.e('Errore durante la mappatura da WorkEntryDTO a WorkEntry',
          error: e);
      throw Exception(
          'Errore durante la mappatura da WorkEntryDTO a WorkEntry: ${e.toString()}. Si prega di verificare i dati del DTO e contattare l\'assistenza se il problema persiste.');
    }
  }

  /// Mappa un'entità `WorkEntry` in un oggetto `WorkEntryDTO`.
  WorkEntryDTO toDTO(WorkEntry entry) {
    try {
      return WorkEntryDTO(
        id: entry.id,
        timestamp: entry.timestamp,
        isEntry: entry.isEntry,
      );
    } catch (e) {
      logger.e('Errore durante la mappatura da WorkEntry a WorkEntryDTO',
          error: e);
      throw Exception(
          'Errore durante la mappatura da WorkEntry a WorkEntryDTO: ${e.toString()}. Si prega di verificare i dati dell\'entità WorkEntry e contattare l\'assistenza se il problema persiste.');
    }
  }
}

```

./lib/data/dependencies/repositories/work_entries_repository.dart:
```
import 'dart:io';
import 'package:csv/csv.dart';
import 'package:file_picker/file_picker.dart';
import 'package:timetrailblazer/data/dependencies/mappers/work_entry_mapper.dart';
import 'package:timetrailblazer/data/dependencies/providers/work_entries_provider.dart';
import 'package:timetrailblazer/domain/entities/work_entry.dart';
import 'package:timetrailblazer/utils/logger.dart';

/// La classe `WorkEntriesRepository` gestisce l'accesso ai dati delle voci di lavoro.
abstract class WorkEntriesRepository {
  WorkEntriesRepository();
}

class WorkEntriesRepositoryImpl implements WorkEntriesRepository {
  final WorkEntriesProvider _workEntriesProvider;
  final WorkEntryMapper _workEntryMapper;

  WorkEntriesRepositoryImpl(
    this._workEntriesProvider,
    this._workEntryMapper,
  );

  /// Inserisce una nuova voce di lavoro.
  Future<void> insertWorkEntry(WorkEntry entry) async {
    try {
      final dto = _workEntryMapper.toDTO(entry);
      await _workEntriesProvider.insertWorkEntry(dto);
    } catch (e) {
      logger.e(
          'Errore durante l\'inserimento della voce di lavoro nel repository',
          error: e);
      throw Exception(
          'Errore durante l\'inserimento della voce di lavoro nel repository: ${e.toString()}');
    }
  }

  /// Recupera le voci di lavoro in base all'intervallo di date specificato.
  Future<List<WorkEntry>> getWorkEntries(
    DateTime startDate,
    DateTime endDate,
  ) async {
    try {
      final dtos = await _workEntriesProvider.getWorkEntries(
        startDate,
        endDate,
      );
      return dtos.map(_workEntryMapper.fromDTO).toList(growable: false);
    } catch (e) {
      logger.e('Errore durante il recupero delle voci di lavoro nel repository',
          error: e);
      throw Exception(
          'Errore durante il recupero delle voci di lavoro nel repository: ${e.toString()}');
    }
  }

  /// Elimina tutte le voci di lavoro.
  Future<void> deleteAllWorkEntries() async {
    try {
      await _workEntriesProvider.deleteAllWorkEntries();
    } catch (e) {
      logger.e(
          'Errore durante l\'eliminazione di tutte le voci di lavoro nel repository',
          error: e);
      throw Exception(
          'Errore durante l\'eliminazione di tutte le voci di lavoro nel repository: ${e.toString()}');
    }
  }

  /// Elimina una specifica voce di lavoro in base all'ID.
  Future<void> deleteWorkEntry(int entryId) async {
    try {
      await _workEntriesProvider.deleteWorkEntry(entryId);
    } catch (e) {
      logger.e(
          'Errore durante l\'eliminazione della voce di lavoro nel repository',
          error: e);
      throw Exception(
          'Errore durante l\'eliminazione della voce di lavoro nel repository: ${e.toString()}');
    }
  }

  /// Aggiorna una voce di lavoro.
  Future<void> updateWorkEntry(WorkEntry entry) async {
    try {
      final dto = _workEntryMapper.toDTO(entry);
      await _workEntriesProvider.updateWorkEntry(dto);
    } catch (e) {
      logger.e(
          'Errore durante l\'aggiornamento della voce di lavoro nel repository',
          error: e);
      throw Exception(
          'Errore durante l\'aggiornamento della voce di lavoro nel repository: ${e.toString()}');
    }
  }

  /// Recupera l'ultima voce di lavoro inserita.
  Future<WorkEntry?> getLastWorkEntry() async {
    try {
      final dto = await _workEntriesProvider.getLastWorkEntry();
      if (dto != null) {
        return _workEntryMapper.fromDTO(dto);
      }
      return null;
    } catch (e) {
      logger.e(
          'Errore durante il recupero dell\'ultima voce di lavoro nel repository',
          error: e);
      throw Exception(
          'Errore durante il recupero dell\'ultima voce di lavoro nel repository: ${e.toString()}');
    }
  }

  /// Esporta le voci di lavoro in un file CSV.
  Future<String> exportToCsv(List<WorkEntry> entries) async {
    try {
      final rows = entries.map((entry) =>
          [entry.id, entry.timestamp.toIso8601String(), entry.isEntry]);

      final csv = const ListToCsvConverter().convert(rows.toList());

      final String? outputFile = await FilePicker.platform.saveFile(
        dialogTitle: 'Salva file CSV',
        fileName: 'voci_di_lavoro.csv',
        type: FileType.custom,
        allowedExtensions: ['csv'],
      );

      if (outputFile == null) {
        throw Exception('Nessun file selezionato');
      }

      final File file = File(outputFile);
      await file.writeAsString(csv);

      return outputFile;
    } catch (e) {
      logger.e('Errore durante l\'esportazione delle voci di lavoro in CSV',
          error: e);
      throw Exception(
          'Errore durante l\'esportazione delle voci di lavoro in CSV: ${e.toString()}');
    }
  }

  /// Importa le voci di lavoro da un file CSV.
  Future<void> importFromCsv(String path) async {
    try {
      final file = File(path);
      final csvString = await file.readAsString();
      final csvList = const CsvToListConverter().convert(csvString);

      final workEntries = csvList.map((row) {
        final id = row[0];
        final timestamp = DateTime.parse(row[1]);
        final isEntry = bool.parse(row[2]);
        return WorkEntry(id: id, timestamp: timestamp, isEntry: isEntry);
      }).toList();

      for (final workEntry in workEntries) {
        await _workEntriesProvider
            .insertWorkEntry(_workEntryMapper.toDTO(workEntry));
      }
    } catch (e) {
      logger.e('Errore durante l\'importazione delle voci di lavoro da CSV',
          error: e);
      throw Exception(
          'Errore durante l\'importazione delle voci di lavoro da CSV: ${e.toString()}');
    }
  }

  /// Calcola il tempo di lavoro giornaliero a partire dalle voci di lavoro.
  Future<Map<DateTime, Duration>> calculateWorkTimeMap() async {
    try {
      final entries = await getWorkEntries(DateTime(2000), DateTime.now());
      final workTimeMap = <DateTime, Duration>{};

      for (int i = 0; i < entries.length; i += 2) {
        final startEntry = entries[i];
        final endEntry = i + 1 < entries.length ? entries[i + 1] : null;

        if (endEntry != null) {
          final workDate = DateTime(
            startEntry.timestamp.year,
            startEntry.timestamp.month,
            startEntry.timestamp.day,
          );
          final workDuration =
              endEntry.timestamp.difference(startEntry.timestamp);
          workTimeMap[workDate] =
              (workTimeMap[workDate] ?? const Duration()) + workDuration;
        }
      }

      return workTimeMap;
    } catch (e) {
      logger.e('Errore durante il calcolo del tempo di lavoro', error: e);
      throw Exception(
          'Errore durante il calcolo del tempo di lavoro: ${e.toString()}');
    }
  }
}

```

./lib/data/models/work_entry_dto.dart:
```
/// La classe `WorkEntryDTO` rappresenta un oggetto di trasferimento dati per una voce di lavoro.
class WorkEntryDTO {
  /// L'ID univoco della voce di lavoro (può essere null per le nuove voci).
  final int? id;
  
  /// Il timestamp della voce di lavoro.
  final DateTime timestamp;
  
  /// Un flag che indica se la voce è un'entrata o un'uscita.
  final bool isEntry;
  
  /// La data della voce di lavoro (senza l'ora).
  final DateTime day;

  WorkEntryDTO({
    this.id,
    required this.timestamp,
    required this.isEntry,
  }) : day = DateTime(timestamp.year, timestamp.month, timestamp.day);

  /// Converte l'oggetto `WorkEntryDTO` in una mappa di chiave-valore.
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'timestamp': timestamp.millisecondsSinceEpoch,
      'is_entry': isEntry ? 1 : 0,
    };
  }

  /// Crea un oggetto `WorkEntryDTO` a partire da una mappa di chiave-valore.
  static WorkEntryDTO fromMap(Map<String, dynamic> map) {
    return WorkEntryDTO(
      id: map['id'],
      timestamp: DateTime.fromMillisecondsSinceEpoch(map['timestamp']),
      isEntry: map['is_entry'] == 1,
    );
  }
}

```

./lib/dependencies/mappers.dart:
```
import 'package:provider/provider.dart';
import 'package:provider/single_child_widget.dart';
import 'package:timetrailblazer/data/dependencies/mappers/work_entry_mapper.dart';

/// Restituisce una lista di `SingleChildWidget` per l'iniezione dei mapper nell'albero dei widget.
List<SingleChildWidget> getMappers() {
  return [
    // Fornisce il `WorkEntryMapper` all'albero dei widget, creandolo quando necessario.
    // Il `WorkEntryMapper` è responsabile della mappatura tra `WorkEntry` e `WorkEntryDTO`.
    Provider<WorkEntryMapper>(
      create: (_) => WorkEntryMapper(),
    ),
  ];
}

```

./lib/dependencies/providers.dart:
```
import 'package:provider/provider.dart';
import 'package:provider/single_child_widget.dart';
import 'package:timetrailblazer/data/database_helper.dart';
import 'package:timetrailblazer/data/dependencies/providers/work_entries_provider.dart';

/// Restituisce una lista di `SingleChildWidget` per l'iniezione dei provider nell'albero dei widget.
List<SingleChildWidget> getProviders(DatabaseHelper databaseHelper) {
  return [
    // Fornisce il `WorkEntriesProvider` all'albero dei widget, creandolo con il `DatabaseHelper`.
    // Il `WorkEntriesProvider` è responsabile dell'accesso ai dati delle voci di lavoro tramite il database.
    Provider<WorkEntriesProvider>(
      create: (_) => WorkEntriesProvider(databaseHelper),
    ),
  ];
}

```

./lib/dependencies/repositories.dart:
```
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:timetrailblazer/data/dependencies/mappers/work_entry_mapper.dart';
import 'package:timetrailblazer/data/dependencies/providers/work_entries_provider.dart';
import 'package:timetrailblazer/data/dependencies/repositories/work_entries_repository.dart';

/// Restituisce una lista di `RepositoryProvider` per l'iniezione dei repository nell'albero dei widget.
List<RepositoryProvider<dynamic>> getRepositories() {
  return [
    // Fornisce il `WorkEntriesRepository` all'albero dei widget, creandolo con il `WorkEntriesProvider` e il `WorkEntryMapper`.
    // Il `WorkEntriesRepository` è responsabile dell'accesso ai dati delle voci di lavoro e della loro gestione.
    RepositoryProvider<WorkEntriesRepositoryImpl>(
      create: (context) => WorkEntriesRepositoryImpl(
        context.read<WorkEntriesProvider>(),
        context.read<WorkEntryMapper>(),
      ),
    ),
  ];
}

```

./lib/dependencies/bloc_providers.dart:
```
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:timetrailblazer/data/dependencies/repositories/work_entries_repository.dart';
import 'package:timetrailblazer/domain/blocs/home_page/home_bloc.dart';
import 'package:timetrailblazer/domain/blocs/work_entries/work_entries_bloc.dart';

/// Restituisce una lista di `BlocProvider` per l'iniezione dei BLoC nell'albero dei widget.
List<BlocProvider<StateStreamableSource<Object?>>> getBlocProviders() {
  return [
    // Fornisce il `WorkEntriesBloc` all'albero dei widget, creandolo con il `WorkEntriesRepository`.
    // Il `WorkEntriesBloc` è responsabile della gestione dello stato relativo alle voci di lavoro.
    BlocProvider<WorkEntriesBloc>(
      create: (context) => WorkEntriesBloc(
        context.read<WorkEntriesRepositoryImpl>(),
      ),
    ),

    // Fornisce il `HomeBloc` all'albero dei widget, creandolo senza dipendenze esterne.
    // Il `HomeBloc` è responsabile della gestione dello stato relativo alla schermata principale dell'applicazione.
    BlocProvider<HomeBloc>(
      create: (context) => HomeBloc(),
    ),
  ];
}

```

./lib/utils/logger.dart:
```
import 'package:logger/logger.dart';

/// Istanza del logger utilizzata per registrare i messaggi di log nell'applicazione.
///
/// Il logger è configurato con le seguenti opzioni:
/// - `methodCount`: il numero di metodi da visualizzare nella traccia dello stack.
/// - `errorMethodCount`: il numero di metodi da visualizzare nella traccia dello stack in caso di errore.
/// - `lineLength`: la lunghezza massima di ogni riga di log.
/// - `colors`: abilita i colori nella console per una migliore leggibilità.
/// - `printEmojis`: abilita l'uso di emoji nei messaggi di log.
/// - `printTime`: abilita la stampa del timestamp per ogni messaggio di log.
final logger = Logger(
  printer: PrettyPrinter(
    methodCount: 2,
    errorMethodCount: 8,
    lineLength: 120,
    colors: true,
    printEmojis: true,
    printTime: true,
  ),
);

```

./lib/utils/error_handler.dart:
```
import 'package:flutter/material.dart';
import 'package:timetrailblazer/utils/navigator_key.dart';

/// Classe che fornisce metodi statici per la gestione e la visualizzazione degli errori nell'applicazione.
class ErrorHandler {
  /// Mostra una SnackBar con un messaggio di errore.
  ///
  /// Parametri:
  /// - `context`: il contesto del widget in cui mostrare la SnackBar.
  /// - `message`: il messaggio di errore da visualizzare.
  static void showErrorSnackBar(String message) {
    // Utilizza un metodo statico per mostrare uno SnackBar senza il BuildContext
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final context = NavigatorKey.currentContext;
      if (context != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(message),
            duration: const Duration(seconds: 3),
            backgroundColor: Colors.red,
          ),
        );
      }
    });
  }

  /// Mostra un dialogo di errore con un titolo e un messaggio.
  ///
  /// Parametri:
  /// - `context`: il contesto del widget in cui mostrare il dialogo.
  /// - `title`: il titolo del dialogo di errore.
  /// - `message`: il messaggio di errore da visualizzare.
  static void showErrorDialog(String title, String message) {
    // Utilizza un metodo statico per mostrare un AlertDialog senza il BuildContext
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final context = NavigatorKey.currentContext;
      if (context != null) {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: Text(title),
            content: Text(message),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('OK'),
              ),
            ],
          ),
        );
      }
    });
  }

  /// Mostra una notifica di errore prominente utilizzando un MaterialBanner.
  ///
  /// Parametri:
  /// - `context`: il contesto del widget in cui mostrare la notifica.
  /// - `message`: il messaggio di errore da visualizzare.
  static void showErrorNotification(String message) {
    // Utilizza un metodo statico per mostrare un MaterialBanner senza il BuildContext
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final context = NavigatorKey.currentContext;
      if (context != null) {
        ScaffoldMessenger.of(context).showMaterialBanner(
          MaterialBanner(
            content: Text(message),
            leading: const Icon(Icons.error, color: Colors.white),
            backgroundColor: Colors.red,
            actions: [
              TextButton(
                onPressed: () =>
                    ScaffoldMessenger.of(context).hideCurrentMaterialBanner(),
                child: const Text('DISMISS',
                    style: TextStyle(color: Colors.white)),
              ),
            ],
          ),
        );
      }
    });
  }
}

```

./lib/utils/navigator_key.dart:
```
import 'package:flutter/material.dart';

/// Classe che fornisce una chiave di navigazione globale per accedere al contesto corrente.
class NavigatorKey {
  static final GlobalKey<NavigatorState> navigatorKey =
      GlobalKey<NavigatorState>();

  /// Restituisce il contesto corrente dell'applicazione.
  static BuildContext? get currentContext => navigatorKey.currentContext;
}

```

