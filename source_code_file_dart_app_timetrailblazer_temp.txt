./lib/main.dart:
```
import 'package:flutter/material.dart';
import 'package:timetrailblazer/app_initializer.dart';

/// Il punto di ingresso dell'applicazione TimeTrailBlazer.
///
/// Questa funzione `main` esegue le seguenti operazioni:
/// 1. Chiama il metodo `initialize` della classe `AppInitializer` per inizializzare l'app.
/// 2. Avvia l'applicazione Flutter con il widget root restituito da `AppInitializer.initialize()`.
void main() async {
  final app = await AppInitializer.initialize();
  runApp(app);
}
```

./lib/domain/blocs/home_page/home_bloc.dart:
```
import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:timetrailblazer/data/datasources/repositories/work_entry_repository.dart';
import 'package:timetrailblazer/data/models/work_entry_model.dart';

part 'home_event.dart';
part 'home_state.dart';

/// Il BLoC che gestisce lo stato della schermata principale.
class HomeBloc extends Bloc<HomeEvent, HomeState> {
  /// Il repository delle voci di lavoro.
  final WorkEntryRepository _workEntryRepository;

  /// Costruttore del BLoC.
  ///
  /// Inizializza lo stato iniziale del BLoC a `HomeInitial`.
  /// Riceve come dipendenza il [WorkEntryRepository] per interagire con il database.
  HomeBloc(this._workEntryRepository) : super(HomeInitial()) {
    /// Gestisce l'evento `EntryButtonPressed`.
    on<EntryButtonPressed>(_onEntryButtonPressed);

    /// Gestisce l'evento `ExitButtonPressed`.
    on<ExitButtonPressed>(_onExitButtonPressed);
  }

  /// Gestore dell'evento `EntryButtonPressed`.
  ///
  /// Quando viene premuto il pulsante di entrata:
  /// 1. Inserisce una nuova voce di lavoro di tipo "entrata" nel database.
  /// 2. Recupera l'ultima voce di lavoro dal database.
  /// 3. Emette lo stato `HomeExitButtonEnabled` se l'ultima voce è di tipo "entrata",
  ///    altrimenti emette lo stato `HomeEntryButtonEnabled`.
  Future<void> _onEntryButtonPressed(
      EntryButtonPressed event, Emitter<HomeState> emit) async {
    await _workEntryRepository.insertWorkEntry(
      WorkEntryModel(timestamp: DateTime.now(), isEntry: true),
    );

    final lastWorkEntry = await _workEntryRepository.getLastWorkEntry();
    if (lastWorkEntry != null && lastWorkEntry.isEntry!) {
      emit(HomeExitButtonEnabled());
    } else {
      emit(HomeEntryButtonEnabled());
    }
  }

  /// Gestore dell'evento `ExitButtonPressed`.
  ///
  /// Quando viene premuto il pulsante di uscita:
  /// 1. Inserisce una nuova voce di lavoro di tipo "uscita" nel database.
  /// 2. Recupera l'ultima voce di lavoro dal database.
  /// 3. Emette lo stato `HomeEntryButtonEnabled` se l'ultima voce è di tipo "uscita",
  ///    altrimenti emette lo stato `HomeExitButtonEnabled`.
  Future<void> _onExitButtonPressed(
      ExitButtonPressed event, Emitter<HomeState> emit) async {
    await _workEntryRepository.insertWorkEntry(
      WorkEntryModel(timestamp: DateTime.now(), isEntry: false),
    );

    final lastWorkEntry = await _workEntryRepository.getLastWorkEntry();
    if (lastWorkEntry != null && !lastWorkEntry.isEntry!) {
      emit(HomeEntryButtonEnabled());
    } else {
      emit(HomeExitButtonEnabled());
    }
  }
}

```

./lib/domain/blocs/home_page/home_state.dart:
```
part of 'home_bloc.dart';

/// Rappresenta lo stato del BLoC `HomeBloc`.
abstract class HomeState extends Equatable {
  const HomeState();

  @override
  List<Object> get props => [];
}

/// Rappresenta lo stato iniziale del BLoC `HomeBloc`.
class HomeInitial extends HomeState {}

/// Rappresenta lo stato in cui il pulsante di entrata è abilitato e il pulsante di uscita è disabilitato.
class HomeEntryButtonEnabled extends HomeState {
}

/// Rappresenta lo stato in cui il pulsante di uscita è abilitato e il pulsante di entrata è disabilitato.
class HomeExitButtonEnabled extends HomeState {}
```

./lib/domain/blocs/home_page/home_event.dart:
```
part of 'home_bloc.dart';

/// Rappresenta un evento del BLoC `HomeBloc`.
abstract class HomeEvent extends Equatable {
  const HomeEvent();

  @override
  List<Object> get props => [];
}

/// Rappresenta l'evento di pressione del pulsante di entrata.
class EntryButtonPressed extends HomeEvent {
}

/// Rappresenta l'evento di pressione del pulsante di uscita.
class ExitButtonPressed extends HomeEvent {
}

```

./lib/domain/blocs/work_entries/work_entries_event.dart:
```
part of 'work_entries_bloc.dart';

/// Rappresenta un evento del BLoC `WorkEntriesBloc`.
abstract class WorkEntriesEvent extends Equatable {
  const WorkEntriesEvent();

  @override
  List<Object> get props => [];
}

/// Rappresenta l'evento di richiesta delle voci di lavoro per un intervallo di date.
class FetchWorkEntries extends WorkEntriesEvent {
  /// La data di inizio dell'intervallo.
  final DateTime startDate;

  /// La data di fine dell'intervallo.
  final DateTime endDate;

  const FetchWorkEntries({
    required this.startDate,
    required this.endDate,
  });

  @override
  List<Object> get props => [startDate, endDate];
}
```

./lib/domain/blocs/work_entries/work_entries_state.dart:
```
part of 'work_entries_bloc.dart';

/// Rappresenta lo stato del BLoC `WorkEntriesBloc`.
abstract class WorkEntriesState extends Equatable {
  const WorkEntriesState();

  @override
  List<Object> get props => [];
}

/// Rappresenta lo stato iniziale del BLoC `WorkEntriesBloc`.
class WorkEntriesInitial extends WorkEntriesState {}

/// Rappresenta lo stato di caricamento delle voci di lavoro.
class WorkEntriesLoading extends WorkEntriesState {}

/// Rappresenta lo stato di caricamento completato delle voci di lavoro.
class WorkEntriesLoaded extends WorkEntriesState {
  /// La lista delle voci di lavoro raggruppate per giorno.
  final List<DayWorkEntriesModel> dayWorkEntriesList;

  const WorkEntriesLoaded({required this.dayWorkEntriesList});

  @override
  List<Object> get props => [dayWorkEntriesList];
}

/// Rappresenta lo stato di errore durante il caricamento delle voci di lavoro.
class WorkEntriesError extends WorkEntriesState {
  /// Il messaggio di errore.
  final String message;

  const WorkEntriesError({required this.message});

  @override
  List<Object> get props => [message];
}
```

./lib/domain/blocs/work_entries/work_entries_bloc.dart:
```
import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:timetrailblazer/data/datasources/repositories/work_entry_repository.dart';
import 'package:timetrailblazer/data/models/day_work_entries_model.dart';

part 'work_entries_event.dart';
part 'work_entries_state.dart';

/// Il BLoC che gestisce lo stato delle voci di lavoro.
class WorkEntriesBloc extends Bloc<WorkEntriesEvent, WorkEntriesState> {
  /// Il repository delle voci di lavoro.
  final WorkEntryRepository _workEntryRepository;

  /// Costruttore del BLoC.
  ///
  /// Inizializza lo stato iniziale del BLoC a `WorkEntriesInitial`.
  /// Riceve come dipendenza il [WorkEntryRepository] per interagire con il database.
  WorkEntriesBloc(this._workEntryRepository) : super(WorkEntriesInitial()) {
    /// Gestisce l'evento `FetchWorkEntries`.
    on<FetchWorkEntries>(_onFetchWorkEntries);

    // Aggiungi altri gestori di eventi se necessario
  }

  /// Gestore dell'evento `FetchWorkEntries`.
  ///
  /// Quando viene richiesto il recupero delle voci di lavoro:
  /// 1. Emette lo stato `WorkEntriesLoading` per indicare che è in corso il caricamento.
  /// 2. Genera la lista di giorni compresi tra la data di inizio e la data di fine.
  /// 3. Recupera le voci di lavoro dal repository per i giorni generati.
  /// 4. Emette lo stato `WorkEntriesLoaded` con le voci di lavoro recuperate.
  /// 5. In caso di errore, emette lo stato `WorkEntriesError` con un messaggio di errore.
  Future<void> _onFetchWorkEntries(
      FetchWorkEntries event, Emitter<WorkEntriesState> emit) async {
    emit(WorkEntriesLoading());
    try {
      final startDate = event.startDate;
      final endDate = event.endDate;

      // Genera la lista di giorni compresi tra la data di inizio e la data di fine
      final days = List.generate(
        endDate.difference(startDate).inDays + 1,
        (index) => startDate.add(Duration(days: index)),
      );

      // Recupera le voci di lavoro dal repository per i giorni generati
      final dayWorkEntriesList =
          await _workEntryRepository.getWorkEntriesByDays(
        days,
        endDate,
      );

      emit(WorkEntriesLoaded(dayWorkEntriesList: dayWorkEntriesList));
    } catch (error) {
      emit(WorkEntriesError(
          message: 'Errore durante il caricamento delle voci di lavoro'));
    }
  }

  // Aggiungi altri metodi per gestire altri eventi se necessario
}

```

./lib/app.dart:
```
import 'package:flutter/material.dart';
import 'package:timetrailblazer/config/constants_routes.dart';
import 'package:timetrailblazer/presentation/screens/home_page_screen.dart';
import 'package:timetrailblazer/presentation/screens/work_entries_screen.dart';
import 'package:timetrailblazer/presentation/screens/work_stats_screen.dart';

/// La classe principale dell'applicazione che rappresenta il punto di ingresso dell'app.
/// Estende la classe `StatelessWidget` di Flutter, che indica che questo widget non ha uno stato mutabile.
class App extends StatelessWidget {
  /// Il costruttore della classe `App`.
  /// Accetta una chiave opzionale `key` che viene passata al costruttore della superclasse `StatelessWidget`.
  const App({super.key});

  /// Il metodo `build` è un override del metodo della superclasse `StatelessWidget`.
  /// Viene chiamato quando il widget deve essere renderizzato.
  /// Accetta un parametro `context` che rappresenta la posizione del widget nell'albero dei widget.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title:
          'timetrailblazer', // Il titolo dell'applicazione, utilizzato per scopi di accessibilità e indicizzazione
      initialRoute: AppRoutes
          .home, // La rotta iniziale dell'applicazione, in questo caso la HomePage
      routes: {
        // Un oggetto `Map` che definisce le rotte dell'applicazione e i corrispondenti widget da visualizzare
        AppRoutes.home: (context) =>
            const HomePageScreen(), // La rotta per la HomePage, che viene visualizzata quando l'app viene avviata
        AppRoutes.workEntries: (context) =>
            const WorkEntriesScreen(), // La rotta per la WorkEntriesScreen, che mostra le voci di lavoro registrate
        AppRoutes.workStats: (context) =>
            const WorkStatsScreen(), // La rotta per la WorkStatsScreen, che mostra le statistiche di lavoro
      },
    );
  }
}

```

./lib/config/constants_routes.dart:
```
class AppRoutes {
  static const String home = '/';
  static const String workEntries = '/work_entries';
  static const String workStats = '/work_stats';
}

```

./lib/config/constants_string.dart:
```
// Costanti per i testi
class AppStrings {
  static const String entryRegistered = 'Entrata registrata';
  static const String exitRegistered = 'Uscita registrata';
  static const String appName = 'TimeTrailblazer';
  static const String appFooter =
      'TimeTrailblazer - L\'app per una gestione del tempo impeccabile, sviluppata da Neo1777.';
  static const String appTitle = 'Registrazione Orari di Lavoro';
  static const String homeTitle = 'Registrazione orari di lavoro';
  static const String appDescription =
      'L\'app essenziale per tracciare i tuoi orari di lavoro.';
  static const String workEntriesTitle = 'Registrazioni Orari di Lavoro';
  static const String workStatsTitle = 'Statistiche di lavoro';
  static const String confirmResetTitle = 'Conferma Reset';
  static const String confirmResetMessage =
      'Sei sicuro di voler resettare il database? Questa azione è irreversibile.';
  static const String cancelButtonText = 'Annulla';
  static const String confirmButtonText = 'Conferma';
  static const String databaseResetSuccess = 'Database resettato con successo';
  static const String databaseResetError =
      'Errore durante il reset del database:';
  static const String dataLoadError = 'Errore nel caricamento dei dati';
  static const String editWorkEntryTitle = 'Modifica registrazione';
  static const String date = 'Data';
  static const String time = 'Ora';
  static const String selectDate = 'Seleziona data';
  static const String selectTime = 'Seleziona ora';
  static const String save = 'Salva';
  static const String error = 'Errore';
  static const String entryButtonLabel = 'Entrata';
  static const String exitButtonLabel = 'Uscita';
  static const String viewEntriesButtonLabel = 'Visualizza registrazioni';
}

// Costanti per i testi di successo
class AppSuccessMessages {
  static const String csvImportCompleted = 'Importazione CSV completata';
  static const String csvExportCompleted =
      'File CSV esportato correttamente in';
}

// Costanti per i testi di errore
class AppErrorMessages {
  static const String insertEntryError =
      'Errore durante l\'inserimento della voce di lavoro';
  static const String getEntriesError =
      'Errore durante il recupero delle voci di lavoro';
  static const String resetDatabaseError =
      'Errore durante il reset del database';
  static const String invalidDate = 'Data non valida';
  static const String invalidDateMessage =
      'Non è possibile registrare voci di lavoro per date precedenti a ieri. Per favore, seleziona una data valida.';
  static const String invalidTime = 'Orario non valido';
  static const String invalidTimeMessage =
      'Non è possibile selezionare un orario futuro. Per favore, seleziona un orario valido.';
  static const String updateError = 'Errore di aggiornamento';
  static String updateErrorMessage(String message) =>
      'Errore durante l\'aggiornamento della voce di lavoro: $message. Si prega di verificare i dati inseriti e riprovare. Se il problema persiste, contattare l\'assistenza.';
  static const String registrationError = 'Errore di registrazione';
  static String registrationErrorMessage(String message) =>
      'Errore durante la registrazione della voce di lavoro: $message. Si prega di verificare i dati inseriti e riprovare. Se il problema persiste, contattare l\'assistenza.';
  static const String csvExportError = 'Errore durante l\'esportazione CSV:';
  static const String csvImportError = 'Errore durante l\'importazione CSV:';
  static const String csvSelectError =
      'Errore durante la selezione del file CSV. Per favore, riprova e seleziona un file CSV valido.';
  static const String csvSelectNullError =
      'Nessun file CSV selezionato. Per favore, seleziona un file CSV per l\'importazione.';
  static const String fetchEntriesError =
      'Errore durante il recupero delle voci di lavoro';
  static String fetchEntriesErrorMessage(String message) =>
      'Errore durante il recupero delle voci di lavoro: $message. Si prega di riprovare più tardi o contattare l\'assistenza se il problema persiste.';
  static const String workEntriesOperationError =
      'Errore durante l\'operazione sulle voci di lavoro';
  static String workEntriesOperationErrorMessage(String message) =>
      'Errore durante l\'operazione sulle voci di lavoro: $message. Si prega di verificare la connessione di rete e riprovare. Se il problema persiste, contattare l\'assistenza.';
  static const String loadStatsError =
      'Errore durante il caricamento delle statistiche';
  static const String retryOrCheckNetwork =
      'Si prega di riprovare più tardi o verificare la connessione di rete.';
  static const String checkStorageAndPermissions =
      'Si prega di verificare che ci sia spazio sufficiente sul dispositivo e che l\'applicazione abbia i permessi necessari per scrivere i file.';
  static const String csvFileNotFound = 'File CSV non trovato';
  static const String emptyCsvFile = 'File CSV vuoto';
  static const String retryLater = 'Si prega di riprovare più tardi.';
  static const updateDateError =
      'Errore durante l\'aggiornamento della data della voce di lavoro';
  static updateDateErrorMessage(String message) =>
      'Errore durante l\'aggiornamento della data della voce di lavoro: $message. Si prega di verificare la data selezionata e riprovare.';
  static const updateTimeError =
      'Errore durante l\'aggiornamento dell\'ora della voce di lavoro';
  static updateTimeErrorMessage(String message) =>
      'Errore durante l\'aggiornamento dell\'ora della voce di lavoro: $message. Si prega di verificare l\'ora selezionata e riprovare.';
  static const providerInsertError =
      'Errore durante l\'inserimento della voce di lavoro';
  static providerInsertErrorMessage(String message) =>
      'Errore durante l\'inserimento della voce di lavoro: $message';
  static const providerGetError =
      'Errore durante il recupero delle voci di lavoro';
  static providerGetErrorMessage(String message) =>
      'Errore durante il recupero delle voci di lavoro: $message';
  static const providerDeleteAllError =
      'Errore durante l\'eliminazione di tutte le voci di lavoro';
  static providerDeleteAllErrorMessage(String message) =>
      'Errore durante l\'eliminazione di tutte le voci di lavoro: $message';
  static const providerDeleteError =
      'Errore durante l\'eliminazione della voce di lavoro';
  static providerDeleteErrorMessage(String message) =>
      'Errore durante l\'eliminazione della voce di lavoro: $message';
  static const providerUpdateError =
      'Errore durante l\'aggiornamento della voce di lavoro';
  static providerUpdateErrorMessage(String message) =>
      'Errore durante l\'aggiornamento della voce di lavoro: $message';
  static const providerGetLastError =
      'Errore durante il recupero dell\'ultima voce di lavoro';
  static providerGetLastErrorMessage(String message) =>
      'Errore durante il recupero dell\'ultima voce di lavoro: $message';
  static const repositoryInsertError =
      'Errore durante l\'inserimento della voce di lavoro nel repository';
  static repositoryInsertErrorMessage(String message) =>
      'Errore durante l\'inserimento della voce di lavoro nel repository: $message';
  static const repositoryGetError =
      'Errore durante il recupero delle voci di lavoro nel repository';
  static repositoryGetErrorMessage(String message) =>
      'Errore durante il recupero delle voci di lavoro nel repository: $message';
  static const repositoryDeleteAllError =
      'Errore durante l\'eliminazione di tutte le voci di lavoro nel repository';
  static repositoryDeleteAllErrorMessage(String message) =>
      'Errore durante l\'eliminazione di tutte le voci di lavoro nel repository: $message';
  static const repositoryDeleteError =
      'Errore durante l\'eliminazione della voce di lavoro nel repository';
  static repositoryDeleteErrorMessage(String message) =>
      'Errore durante l\'eliminazione della voce di lavoro nel repository: $message';
  static const repositoryUpdateError =
      'Errore durante l\'aggiornamento della voce di lavoro nel repository';
  static repositoryUpdateErrorMessage(String message) =>
      'Errore durante l\'aggiornamento della voce di lavoro nel repository: $message';
  static const repositoryGetLastError =
      'Errore durante il recupero dell\'ultima voce di lavoro nel repository';
  static repositoryGetLastErrorMessage(String message) =>
      'Errore durante il recupero dell\'ultima voce di lavoro nel repository: $message';
  static const repositoryExportError =
      'Errore durante l\'esportazione delle voci di lavoro in CSV';
  static repositoryExportErrorMessage(String message) =>
      'Errore durante l\'esportazione delle voci di lavoro in CSV: $message';
  static const repositoryImportError =
      'Errore durante l\'importazione delle voci di lavoro da CSV';
  static repositoryImportErrorMessage(String message) =>
      'Errore durante l\'importazione delle voci di lavoro da CSV: $message';
  static const repositoryCalculateError =
      'Errore durante il calcolo del tempo di lavoro';
  static repositoryCalculateErrorMessage(String message) =>
      'Errore durante il calcolo del tempo di lavoro: $message';
}

```

./lib/presentation/widgets/auto_size_text.dart:
```
import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/material.dart';

class CustomAutoSizeText extends StatelessWidget {
  final String text;
  final TextStyle style;
  final TextAlign textAlign;

  const CustomAutoSizeText(this.text, this.style, this.textAlign, {super.key});

  @override
  Widget build(BuildContext context) {
    return AutoSizeText(
      text,
      textAlign: textAlign,
      style: style,
      minFontSize: 0,
      maxLines: null,
      overflow: TextOverflow.fade,
    );
  }
}

```

./lib/presentation/widgets/app_bar.dart:
```
import 'package:flutter/material.dart';
import 'package:timetrailblazer/presentation/widgets/auto_size_text.dart';

class CustomAppBar extends StatelessWidget implements PreferredSizeWidget {
  final String title;
  final VoidCallback? onBackPressed;
  final List<Widget>? onAction;

  const CustomAppBar({
    super.key,
    this.onBackPressed,
    this.onAction,
    required this.title,
  });

  @override
  Widget build(BuildContext context) {
    return AppBar(
      //backgroundColor: Colors.transparent,
      automaticallyImplyLeading: true,
      actions: onAction,
      leading: IconButton(
        visualDensity: VisualDensity.adaptivePlatformDensity,
        icon: const Icon(Icons.arrow_back_ios_new),
        onPressed: onBackPressed,
      ),
      title: CustomAutoSizeText(
        title,
        Theme.of(context).textTheme.titleSmall!,
        TextAlign.center,
      ),
      titleSpacing: 0,
      centerTitle: false,
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(32);
}

```

./lib/presentation/widgets/work_button.dart:
```
import 'package:flutter/material.dart';

/// Il widget `WorkButton` rappresenta un pulsante personalizzato per le azioni di entrata e uscita.
class WorkButton extends StatelessWidget {
  /// L'etichetta del pulsante.
  final String label;

  /// La funzione di callback da chiamare quando il pulsante viene premuto.
  final VoidCallback? onPressed;

  /// La larghezza del pulsante.
  final double? width;

  const WorkButton({
    super.key,
    required this.label,
    this.onPressed,
    this.width,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: width,
      child: ElevatedButton(
        onPressed: onPressed,
        child: Text(
          label,
        ),
      ),
    );
  }
}

```

./lib/presentation/widgets/date_range_picker.dart:
```
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

/// Il widget `DateRangePicker` consente all'utente di selezionare un intervallo di date.
class DateRangePicker extends StatelessWidget {
  /// La data di inizio dell'intervallo selezionato.
  final DateTime startDate;

  /// La data di fine dell'intervallo selezionato.
  final DateTime endDate;

  /// La funzione di callback da chiamare quando la data di inizio viene modificata.
  final Function(DateTime) onStartDateChanged;

  /// La funzione di callback da chiamare quando la data di fine viene modificata.
  final Function(DateTime) onEndDateChanged;

  /// La funzione di callback da chiamare quando viene premuto il pulsante "Mese corrente".
  final VoidCallback onCurrentMonthPressed;

  const DateRangePicker({
    super.key,
    required this.startDate,
    required this.endDate,
    required this.onStartDateChanged,
    required this.onEndDateChanged,
    required this.onCurrentMonthPressed,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        Flexible(
          child: ElevatedButton(
            onPressed: () => _selectDate(context, true),
            child: Text('Dal: ${DateFormat('dd/MM/yyyy').format(startDate)}'),
          ),
        ),
        Flexible(
          child: ElevatedButton(
            onPressed: () => _selectDate(context, false),
            child: Text('Al: ${DateFormat('dd/MM/yyyy').format(endDate)}'),
          ),
        ),
        Flexible(
          child: ElevatedButton(
            onPressed: onCurrentMonthPressed,
            child: const Text('Mese corrente'),
          ),
        ),
      ],
    );
  }

  /// Mostra un selettore di data e chiama la funzione di callback appropriata quando una data viene selezionata.
  ///
  /// Parametri:
  ///   - `context`: il contesto del widget.
  ///   - `isStartDate`: un flag che indica se la data selezionata è la data di inizio o di fine.
  Future<void> _selectDate(BuildContext context, bool isStartDate) async {
    final DateTime? pickedDate = await showDatePicker(
      context: context,
      initialDate: isStartDate ? startDate : endDate,
      firstDate: isStartDate ? DateTime(2000) : startDate,
      lastDate: isStartDate ? endDate : DateTime(2100),
    );

    if (pickedDate != null) {
      isStartDate
          ? onStartDateChanged(pickedDate)
          : onEndDateChanged(pickedDate);
    }
  }
}

```

./lib/presentation/widgets/spacer.dart:
```
import 'package:flutter/material.dart';

class CustomSpacer extends StatelessWidget {
  final int flex;

  const CustomSpacer({super.key, this.flex = 1});

  @override
  Widget build(BuildContext context) {
    return Spacer(flex: flex);
  }
}

```

./lib/presentation/widgets/widgets_screens/day_range_calendar.dart:
```
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:timetrailblazer/data/models/day_work_entries_model.dart';
import 'package:timetrailblazer/data/models/work_entry_model.dart';
import 'package:timetrailblazer/presentation/widgets/spacer.dart';

/// Il widget `DayRangeCalendar` visualizza le voci di lavoro in un calendario variabile.
///
/// Questo widget accetta una lista di oggetti `DayWorkEntries` che rappresentano i giorni
/// e le relative voci di lavoro. Ogni giorno viene visualizzato in una scheda (card)
/// scorrevole, mostrando la data e le voci di lavoro corrispondenti.
class DayRangeCalendar extends StatelessWidget {
  /// La lista di oggetti `DayWorkEntries` che rappresentano i giorni e le voci di lavoro.
  final List<DayWorkEntriesModel> dayWorkEntriesList;

  /// Il controller di scorrimento per il calendario.
  final ScrollController scrollController;

  /// Costruisce un'istanza di `DayRangeCalendar`.
  ///
  /// Richiede la lista di oggetti `DayWorkEntries` [dayWorkEntriesList] e il controller
  /// di scorrimento [scrollController].
  const DayRangeCalendar({
    super.key,
    required this.dayWorkEntriesList,
    required this.scrollController,
  });

  @override
  Widget build(BuildContext context) {
    return GridView.builder(
      controller: scrollController,
      itemCount: dayWorkEntriesList.length,
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 3,
        childAspectRatio: 2.0,
        mainAxisSpacing: 10.0,
        crossAxisSpacing: 10.0,
      ),
      itemBuilder: (context, index) {
        final dayWorkEntries = dayWorkEntriesList[index];
        final day = dayWorkEntries.day;
        final workEntries = dayWorkEntries.workEntries;

        return _buildDayCard(context, day, workEntries);
      },
    );
  }

  /// Costruisce una scheda (card) per un giorno specifico nel calendario.
  ///
  /// La scheda mostra la data formattata del giorno e un elenco delle voci di lavoro
  /// corrispondenti a quel giorno. Ogni voce di lavoro è rappresentata da una riga
  /// con l'orario di entrata/uscita e un indicatore colorato.
  Widget _buildDayCard(
      BuildContext context, DateTime day, List<WorkEntryModel>? workEntries) {
    final formattedDate = DateFormat('EEE, dd MMM yyyy', 'it_IT').format(day);

    return Card(
      elevation: 4,
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            // Mostra la data formattata del giorno
            Flexible(
              flex: 3,
              child: Text(
                formattedDate,
                style: Theme.of(context).textTheme.titleMedium,
              ),
            ),
            // Mostra le voci di lavoro per il giorno corrente, se presenti
            if (workEntries != null)
              ...workEntries.map((entry) {
                final entryColor =
                    entry.isEntry! ? Colors.greenAccent : Colors.redAccent;
                final entryText = entry.isEntry! ? 'Entrata' : 'Uscita';
                return Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    // Mostra l'orario di entrata/uscita
                    Flexible(
                      flex: 3,
                      child: Text(
                        '$entryText: ${DateFormat('HH:mm').format(entry.timestamp)}',
                        style: TextStyle(color: entryColor),
                      ),
                    ),
                    // Mostra un indicatore colorato per il tipo di voce (entrata/uscita)
                    Flexible(
                      flex: 1,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(Icons.circle, size: 12, color: entryColor),
                        ],
                      ),
                    ),
                    const CustomSpacer(),
                  ],
                );
              })
            else
              // Mostra un messaggio se non ci sono voci di lavoro per il giorno corrente
              const Text('Nessuna registrazione'),
          ],
        ),
      ),
    );
  }
}

```

./lib/presentation/widgets/common_body.dart:
```
// Crea un nuovo file chiamato 'common_body.dart' e aggiungi il seguente codice:

import 'package:flutter/material.dart';

class CommonBody extends StatelessWidget {
  final Widget child;

  const CommonBody({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    return Container(
      color: Theme.of(context).scaffoldBackgroundColor,
      child: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 390, maxHeight: 844),
          child: child,
        ),
      ),
    );
  }
}

```

./lib/presentation/screens/home_page_screen.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:timetrailblazer/config/constants_string.dart';
import 'package:timetrailblazer/config/constants_routes.dart';
import 'package:timetrailblazer/data/datasources/repositories/work_entry_repository.dart';
import 'package:timetrailblazer/data/models/work_entry_model.dart';
import 'package:timetrailblazer/domain/blocs/home_page/home_bloc.dart';
import 'package:timetrailblazer/presentation/widgets/app_bar.dart';
import 'package:timetrailblazer/presentation/widgets/auto_size_text.dart';
import 'package:timetrailblazer/presentation/widgets/spacer.dart';
import 'package:timetrailblazer/presentation/widgets/work_button.dart';

/// La schermata principale dell'applicazione.
class HomePageScreen extends StatefulWidget {
  const HomePageScreen({super.key});

  @override
  HomePageScreenState createState() => HomePageScreenState();
}

/// Lo stato della schermata principale.
class HomePageScreenState extends State<HomePageScreen> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: const CustomAppBar(
        title: AppStrings.homeTitle,
      ),
      body: BlocBuilder<HomeBloc, HomeState>(
        builder: (context, state) {
          return FutureBuilder<WorkEntryModel?>(
            future: context.read<WorkEntryRepository>().getLastWorkEntry(),
            builder: (context, snapshot) {
              if (snapshot.connectionState == ConnectionState.waiting) {
                // Mostra un indicatore di caricamento mentre il FutureBuilder sta recuperando i dati
                return const Center(child: CircularProgressIndicator());
              }
              if (snapshot.hasError) {
                // Gestisci gli errori del FutureBuilder
                return Center(
                    child: Text('${AppStrings.error}: ${snapshot.error}'));
              }
              final lastWorkEntry = snapshot.data;
              final isEntryAllowed =
                  lastWorkEntry == null || !lastWorkEntry.isEntry!;

              return HomeScreen(isEntryAllowed: isEntryAllowed);
            },
          );
        },
      ),
    );
  }
}

class HomeScreen extends StatelessWidget {
  const HomeScreen({
    super.key,
    required this.isEntryAllowed,
  });

  final bool isEntryAllowed;

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Flexible(
            flex: 1,
            fit: FlexFit.tight,
            child: Container(
              color: Colors.transparent,
            ),
          ),
          const CustomSpacer(flex: 1),
          Flexible(
            flex: 48,
            child: CustomAutoSizeText(
              AppStrings.appName,
              Theme.of(context).textTheme.headlineLarge!,
              TextAlign.center,
            ),
          ),
          Flexible(
            flex: 32,
            child: CustomAutoSizeText(
              AppStrings.appDescription,
              Theme.of(context).textTheme.bodyMedium!,
              TextAlign.center,
            ),
          ),
          const CustomSpacer(flex: 2),
          Flexible(
            flex: 16,
            child: WorkButton(
              label: AppStrings.entryButtonLabel,
              onPressed: isEntryAllowed
                  ? () {
                      // _registerEntry(context, true);
                      context.read<HomeBloc>().add(EntryButtonPressed());
                    }
                  : null,
            ),
          ),
          //const CustomSpacer(flex: 1),
          Flexible(
            flex: 16,
            child: WorkButton(
              label: AppStrings.exitButtonLabel,
              onPressed: !isEntryAllowed
                  ? () {
                      // _registerEntry(context, false);
                      context.read<HomeBloc>().add(ExitButtonPressed());
                    }
                  : null,
            ),
          ),
          //const CustomSpacer(flex: 1),
          Flexible(
            flex: 16,
            child: WorkButton(
              label: AppStrings.viewEntriesButtonLabel,
              onPressed: () {
                Navigator.pushNamed(context, AppRoutes.workEntries);
                //.then((_) => _refreshWorkEntries());
              },
            ),
          ),
          const CustomSpacer(
            flex: 32,
          ),
          Flexible(
            flex: 8,
            child: CustomAutoSizeText(
              AppStrings.appFooter,
              Theme.of(context).textTheme.bodySmall!,
              TextAlign.center,
            ),
          ),
          //const CustomSpacer(flex: 1),
        ],
      ),
    );
  }
}

```

./lib/presentation/screens/edit_work_entry_screen.dart:
```
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:timetrailblazer/config/constants_string.dart';
import 'package:timetrailblazer/data/models/work_entry_model.dart';
import 'package:timetrailblazer/presentation/widgets/app_bar.dart';
import 'package:timetrailblazer/presentation/widgets/auto_size_text.dart';
import 'package:timetrailblazer/presentation/widgets/spacer.dart';
import 'package:timetrailblazer/presentation/widgets/work_button.dart';

/// Schermata per la modifica di una voce di lavoro.
///
/// Questa schermata consente all'utente di modificare i dettagli di una voce di lavoro esistente,
/// come la data e l'ora. Le modifiche vengono salvate quando l'utente preme il pulsante "Salva".
///
/// Esempio di utilizzo:
///
/// Navigator.push(
///   context,
///   MaterialPageRoute(
///     builder: (context) => EditWorkEntryScreen(workEntry: entry),
///   ),
/// );
class EditWorkEntryScreen extends StatelessWidget {
  /// La voce di lavoro da modificare.
  final WorkEntryModel workEntry;

  /// Costruttore della schermata di modifica della voce di lavoro.
  ///
  /// Parametri:
  ///   - `workEntry`: la voce di lavoro da modificare.
  const EditWorkEntryScreen({super.key, required this.workEntry});

  @override
  Widget build(BuildContext context) {
    // Il `BlocProvider` viene utilizzato per fornire il `EditWorkEntryBloc` alla schermata
    // Viene passata la voce di lavoro iniziale al costruttore del bloc
    return const EditWorkEntryView();
    // BlocProvider(
    //   create: (context) => EditWorkEntryBloc(workEntry),
    //   child: const EditWorkEntryView(),
    // );
  }
}

/// Vista della schermata di modifica di una voce di lavoro.
class EditWorkEntryView extends StatelessWidget {
  const EditWorkEntryView({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: CustomAppBar(
        title: AppStrings.editWorkEntryTitle,
        onBackPressed: () => Navigator.pop(context),
      ),
      body: SafeArea(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.end,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            const CustomSpacer(flex: 10),
            Flexible(
              flex: 5,
              fit: FlexFit.loose,
              child: Container(
                color: Colors.transparent,
              ),
            ),
            const CustomSpacer(flex: 5),
            Flexible(
              flex: 30,
              child: CustomAutoSizeText(
                'Data: ${DateFormat('dd/MM/yyyy')}',
                Theme.of(context).textTheme.bodyLarge!,
                TextAlign.left,
              ),
            ),
            const CustomSpacer(flex: 2),
            const Flexible(
              flex: 10,
              child: WorkButton(
                label: AppStrings.selectDate,
                //onPressed: () => _selectDate(context),
              ),
            ),
            const CustomSpacer(flex: 30),
            Flexible(
              flex: 30,
              child: CustomAutoSizeText(
                '${AppStrings.time}: ${TimeOfDay.fromDateTime(DateTime.now()).format(context)}',
                Theme.of(context).textTheme.bodyLarge!,
                TextAlign.left,
              ),
            ),
            const CustomSpacer(flex: 2),
            const Flexible(
              flex: 10,
              child: WorkButton(
                label: AppStrings.selectTime,
                //onPressed: () => _selectTime(context),
              ),
            ),
            const CustomSpacer(flex: 200),
            const Flexible(
              flex: 10,
              child: WorkButton(
                label: AppStrings.save,
                //onPressed: () => _updateWorkEntry(context),
              ),
            ),
            const CustomSpacer(flex: 10),
          ],
        ),
      ),
    );
  }

}

```

./lib/presentation/screens/work_entries_screen.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:timetrailblazer/config/constants_routes.dart';
import 'package:timetrailblazer/config/constants_string.dart';
import 'package:timetrailblazer/domain/blocs/work_entries/work_entries_bloc.dart';
import 'package:timetrailblazer/presentation/widgets/app_bar.dart';
import 'package:timetrailblazer/presentation/widgets/date_range_picker.dart';
import 'package:timetrailblazer/presentation/widgets/spacer.dart';
import 'package:timetrailblazer/presentation/widgets/widgets_screens/day_range_calendar.dart';
import 'package:timetrailblazer/presentation/widgets/work_button.dart';

/// La schermata che mostra le voci di lavoro registrate.
class WorkEntriesScreen extends StatefulWidget {
  const WorkEntriesScreen({super.key});

  @override
  WorkEntriesScreenState createState() => WorkEntriesScreenState();
}

/// Lo stato della schermata delle voci di lavoro.
class WorkEntriesScreenState extends State<WorkEntriesScreen> {
  final ScrollController _scrollController = ScrollController();
  DateTime _startDate = DateTime(DateTime.now().year, DateTime.now().month, 1);
  DateTime _endDate = DateTime(DateTime.now().year, DateTime.now().month + 1, 0);

  @override
  void initState() {
    super.initState();
    // Aggiunta dell'evento per recuperare le voci di lavoro all'inizializzazione dello stato
    context.read<WorkEntriesBloc>().add(FetchWorkEntries(
          startDate: _startDate,
          endDate: _endDate,
        ));
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: CustomAppBar(
        title: AppStrings.workEntriesTitle,
        onBackPressed: () => Navigator.pop(context),
        onAction: [
          const IconButton(
            icon: Icon(Icons.file_upload),
            onPressed: null,
          ),
          const IconButton(
            icon: Icon(Icons.file_download),
            onPressed: null,
          ),
          IconButton(
            icon: const Icon(Icons.delete_forever),
            onPressed: () {
              // TODO: Implementare la logica di eliminazione di tutte le voci di lavoro
            },
          ),
        ],
      ),
      body: BlocBuilder<WorkEntriesBloc, WorkEntriesState>(
        builder: (context, state) {
          if (state is WorkEntriesLoading) {
            // Mostra un indicatore di caricamento mentre le voci di lavoro vengono caricate
            return const Center(child: CircularProgressIndicator());
          } else if (state is WorkEntriesLoaded) {
            final dayWorkEntriesList = state.dayWorkEntriesList;
            return Column(
              children: [
                const CustomSpacer(flex: 1),
                Flexible(
                  flex: 3,
                  child: DateRangePicker(
                    startDate: _startDate,
                    endDate: _endDate,
                    onStartDateChanged: (date) {
                      setState(() {
                        _startDate = date;
                      });
                      // Aggiorna le voci di lavoro quando la data di inizio viene modificata
                      context.read<WorkEntriesBloc>().add(FetchWorkEntries(
                            startDate: _startDate,
                            endDate: _endDate,
                          ));
                    },
                    onEndDateChanged: (date) {
                      setState(() {
                        _endDate = date;
                      });
                      // Aggiorna le voci di lavoro quando la data di fine viene modificata
                      context.read<WorkEntriesBloc>().add(FetchWorkEntries(
                            startDate: _startDate,
                            endDate: _endDate,
                          ));
                    },
                    onCurrentMonthPressed: () {
                      final now = DateTime.now();
                      setState(() {
                        _startDate = DateTime(now.year, now.month, 1);
                        _endDate = DateTime(now.year, now.month + 1, 0);
                      });
                      // Aggiorna le voci di lavoro quando viene premuto il pulsante "Mese corrente"
                      context.read<WorkEntriesBloc>().add(FetchWorkEntries(
                            startDate: _startDate,
                            endDate: _endDate,
                          ));
                    },
                  ),
                ),
                const CustomSpacer(flex: 1),
                Flexible(
                  flex: 3,
                  child: WorkButton(
                    label: AppStrings.workStatsTitle,
                    onPressed: () {
                      Navigator.pushNamed(context, AppRoutes.workStats);
                    },
                  ),
                ),
                const CustomSpacer(flex: 1),
                Expanded(
                  flex: 20,
                  child: DayRangeCalendar(
                    dayWorkEntriesList: dayWorkEntriesList,
                    scrollController: _scrollController,
                  ),
                ),
              ],
            );
          } else if (state is WorkEntriesError) {
            // Mostra un messaggio di errore in caso di errore durante il caricamento delle voci di lavoro
            return Center(child: Text(state.message));
          } else {
            // Stato non gestito, mostra un contenitore vuoto
            return Container();
          }
        },
      ),
    );
  }
}
```

./lib/presentation/screens/work_stats_screen.dart:
```
import 'package:flutter/material.dart';
import 'package:timetrailblazer/config/constants_string.dart';
import 'package:timetrailblazer/presentation/widgets/app_bar.dart';
import 'package:timetrailblazer/presentation/widgets/spacer.dart';

/// La schermata che mostra le statistiche di lavoro.
class WorkStatsScreen extends StatelessWidget {
  const WorkStatsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: CustomAppBar(
        title: AppStrings.workStatsTitle,
        onBackPressed: () => Navigator.pop(context),
      ),
      // Utilizza `FutureBuilder` per gestire il caricamento asincrono delle statistiche dal repository
      body: FutureBuilder<Map<DateTime, Duration>>(
        future: null,
        //context.read<WorkEntriesRepositoryImpl>().calculateWorkTimeMap(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          } else if (snapshot.hasError) {
            // logger.e(AppErrorMessages.loadStatsError, error: snapshot.error);
            // ErrorHandler.showErrorNotification(
            //   '${AppErrorMessages.loadStatsError}: ${snapshot.error}. ${AppErrorMessages.retryLater}',
            // );
            return Container();
          } else {
            //final workTimeMap = snapshot.data!;
            // final workDates = workTimeMap.keys.toList();
            // workDates.sort((a, b) => b.compareTo(a));

            return SafeArea(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.start,
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  Flexible(
                    flex: 1,
                    fit: FlexFit.tight,
                    child: Container(
                      color: Colors.transparent,
                    ),
                  ),
                  const CustomSpacer(flex: 1),
                  const Flexible(flex: 50, child: Placeholder()
                      //
                      // ListView.separated(
                      //   itemCount: workDates.length,
                      //   itemBuilder: (context, index) {
                      //     final workDate = workDates[index];
                      //     final workDuration = workTimeMap[workDate]!;

                      //     // Mostra le statistiche di lavoro giornaliere utilizzando il widget `WorkStatsListItem`
                      //     return Placeholder();
                      //     // WorkStatsListItem(
                      //     //   date: DateFormat('yyyy-MM-dd').format(workDate),
                      //     //   duration: workDuration,
                      //     // );
                      //   },
                      //   separatorBuilder: (context, index) => const Divider(),
                      // ),
                      ),
                  const CustomSpacer(flex: 1),
                ],
              ),
            );
          }
        },
      ),
    );
  }
}

```

./lib/data/dtos/work_entry_dto.dart:
```
/// La classe `WorkEntryDTO` rappresenta l'oggetto di trasferimento dati (DTO) per una voce di lavoro.
class WorkEntryDTO {
  /// L'ID univoco della voce di lavoro (può essere null per le nuove voci).
  final int? id;

  /// Il timestamp della voce di lavoro in millisecondi.
  final int timestamp;

  /// Un flag che indica se la voce è un'entrata (1) o un'uscita (0).
  final int isEntry;

  /// Costruttore della classe `WorkEntryDTO`.
  ///
  /// Accetta i seguenti parametri:
  /// - [id]: l'ID univoco della voce di lavoro (opzionale).
  /// - [timestamp]: il timestamp della voce di lavoro in millisecondi.
  /// - [isEntry]: un flag che indica se la voce è un'entrata (1) o un'uscita (0).
  WorkEntryDTO({
    this.id,
    required this.timestamp,
    required this.isEntry,
  });

  /// Converte l'oggetto `WorkEntryDTO` in una mappa chiave-valore.
  ///
  /// Restituisce una mappa con le seguenti chiavi:
  /// - 'id': l'ID univoco della voce di lavoro.
  /// - 'timestamp': il timestamp della voce di lavoro in millisecondi.
  /// - 'isEntry': un flag che indica se la voce è un'entrata (1) o un'uscita (0).
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'timestamp': timestamp,
      'isEntry': isEntry,
    };
  }

  /// Crea un oggetto `WorkEntryDTO` a partire da una mappa chiave-valore.
  ///
  /// Accetta una mappa con le seguenti chiavi:
  /// - 'id': l'ID univoco della voce di lavoro.
  /// - 'timestamp': il timestamp della voce di lavoro in millisecondi.
  /// - 'isEntry': un flag che indica se la voce è un'entrata (1) o un'uscita (0).
  ///
  /// Restituisce un nuovo oggetto `WorkEntryDTO` inizializzato con i valori della mappa.
  factory WorkEntryDTO.fromMap(Map<String, dynamic> map) {
    return WorkEntryDTO(
      id: map['id'],
      timestamp: map['timestamp'],
      isEntry: map['isEntry'],
    );
  }
}

```

./lib/data/datasources/providers/work_entry_provider.dart:
```
import 'package:timetrailblazer/data/database_helper.dart';
import 'package:timetrailblazer/data/dtos/work_entry_dto.dart';

/// La classe `WorkEntryProvider` fornisce i metodi per interagire con il database
/// attraverso l'utilizzo di `WorkEntryDTO`.
class WorkEntryProvider {
  /// L'istanza di `DatabaseHelper` utilizzata per l'accesso al database.
  final DatabaseHelper _databaseHelper;

  /// Costruttore della classe `WorkEntryProvider`.
  ///
  /// Accetta un parametro [_databaseHelper] di tipo `DatabaseHelper`.
  WorkEntryProvider(this._databaseHelper);

  /// Inserisce una nuova voce di lavoro nel database.
  ///
  /// Accetta un parametro [workEntryDTO] di tipo `WorkEntryDTO` che rappresenta la voce di lavoro da inserire.
  ///
  /// Restituisce un `Future` che si completa quando l'inserimento è terminato.
  Future<void> insertWorkEntry(WorkEntryDTO workEntryDTO) async {
    await _databaseHelper.insertWorkEntry(workEntryDTO);
  }

  /// Recupera l'ultima voce di lavoro inserita nel database.
  ///
  /// Restituisce un `Future` che si completa con un oggetto `WorkEntryDTO` rappresentante l'ultima voce di lavoro,
  /// oppure `null` se non ci sono voci di lavoro nel database.
  Future<WorkEntryDTO?> getLastWorkEntry() async {
    return await _databaseHelper.getLastWorkEntry();
  }

// /// Questo metodo chiama il metodo getWorkEntriesByDateRange del DatabaseHelper passando i timestamp di inizio e di fine.
//   Future<List<WorkEntryDTO>> getWorkEntriesByDateRange(int startTimestamp, int endTimestamp) async {
//   return await _databaseHelper.getWorkEntriesByDateRange(startTimestamp, endTimestamp);
// }

Future<List<WorkEntryDTO>> getWorkEntriesByDateRange(int startTimestamp, int endTimestamp) async {
  return await _databaseHelper.getWorkEntriesByDateRange(startTimestamp, endTimestamp);
}
}

```

./lib/data/datasources/mappers/work_entry_mapper.dart:
```
import 'package:timetrailblazer/data/dtos/work_entry_dto.dart';
import 'package:timetrailblazer/data/models/work_entry_model.dart';

/// La classe `WorkEntryMapper` si occupa di mappare tra `WorkEntryDTO` e `WorkEntry`.
class WorkEntryMapper {
  /// Mappa un oggetto `WorkEntryDTO` in un oggetto `WorkEntry`.
  ///
  /// Accetta un parametro [dto] di tipo `WorkEntryDTO`.
  ///
  /// Restituisce un nuovo oggetto `WorkEntry` inizializzato con i valori del DTO.
  WorkEntryModel fromDTO(WorkEntryDTO dto) {
    return WorkEntryModel(
      id: dto.id,
      timestamp: DateTime.fromMillisecondsSinceEpoch(dto.timestamp),
      isEntry: dto.isEntry == 1,
    );
  }

  /// Mappa un oggetto `WorkEntry` in un oggetto `WorkEntryDTO`.
  ///
  /// Accetta un parametro [model] di tipo `WorkEntry`.
  ///
  /// Restituisce un nuovo oggetto `WorkEntryDTO` inizializzato con i valori del modello.
  WorkEntryDTO toDTO(WorkEntryModel model) {
    return WorkEntryDTO(
      id: model.id,
      timestamp: model.timestamp.millisecondsSinceEpoch,
      isEntry: model.isEntry! ? 1 : 0,
    );
  }
}

```

./lib/data/datasources/repositories/work_entry_repository.dart:
```
import 'package:timetrailblazer/data/datasources/mappers/work_entry_mapper.dart';
import 'package:timetrailblazer/data/datasources/providers/work_entry_provider.dart';
import 'package:timetrailblazer/data/models/day_work_entries_model.dart';
import 'package:timetrailblazer/data/models/work_entry_model.dart';

/// La classe `WorkEntryRepository` rappresenta il repository per la gestione delle voci di lavoro.
class WorkEntryRepository {
  /// L'istanza di `WorkEntryProvider` utilizzata per l'accesso ai dati.
  final WorkEntryProvider _workEntryProvider;
  
  /// L'istanza di `WorkEntryMapper` utilizzata per la mappatura tra `WorkEntryDTO` e `WorkEntry`.
  final WorkEntryMapper _workEntryMapper;

  /// Costruttore della classe `WorkEntryRepository`.
  ///
  /// Accetta i seguenti parametri:
  /// - [_workEntryProvider]: l'istanza di `WorkEntryProvider` per l'accesso ai dati.
  /// - [_workEntryMapper]: l'istanza di `WorkEntryMapper` per la mappatura.
  WorkEntryRepository(this._workEntryProvider, this._workEntryMapper);

  /// Inserisce una nuova voce di lavoro.
  ///
  /// Accetta un parametro [workEntry] di tipo `WorkEntry` che rappresenta la voce di lavoro da inserire.
  ///
  /// Restituisce un `Future` che si completa quando l'inserimento è terminato.
  Future<void> insertWorkEntry(WorkEntryModel workEntry) async {
    final workEntryDTO = _workEntryMapper.toDTO(workEntry);
    await _workEntryProvider.insertWorkEntry(workEntryDTO);
  }

  /// Recupera l'ultima voce di lavoro inserita.
  ///
  /// Restituisce un `Future` che si completa con un oggetto `WorkEntry` rappresentante l'ultima voce di lavoro,
  /// oppure `null` se non ci sono voci di lavoro.
  Future<WorkEntryModel?> getLastWorkEntry() async {
    final workEntryDTO = await _workEntryProvider.getLastWorkEntry();
    if (workEntryDTO != null) {
      return _workEntryMapper.fromDTO(workEntryDTO);
    }
    return null;
  }

//   /// Questo metodo chiama il metodo getWorkEntriesByDateRange del provider
//   /// WorkEntryProvider passando i timestamp di inizio e di fine convertiti in millisecondi.
//   /// Quindi, mappa i WorkEntryDTO restituiti dal provider in oggetti WorkEntry utilizzando
//   /// il metodo fromDTO del WorkEntryMapper.
//   Future<List<WorkEntry>> getWorkEntriesByDateRange(DateTime startDate, DateTime endDate) async {
//   final workEntryDTOs = await _workEntryProvider.getWorkEntriesByDateRange(
//     startDate.millisecondsSinceEpoch,
//     endDate.millisecondsSinceEpoch,
//   );
//   return workEntryDTOs.map(_workEntryMapper.fromDTO).toList();
// }

Future<List<DayWorkEntriesModel>> getWorkEntriesByDays(List<DateTime> days, DateTime endDate) async {
  final List<DayWorkEntriesModel> dayWorkEntriesList = [];

  for (final day in days) {
    final startOfDay = DateTime(day.year, day.month, day.day);
    final endOfDay = startOfDay.add(const Duration(days: 1)).subtract(const Duration(milliseconds: 1));

    final workEntryDTOs = await _workEntryProvider.getWorkEntriesByDateRange(
      startOfDay.millisecondsSinceEpoch,
      endOfDay.millisecondsSinceEpoch,
    );

    final workEntries = workEntryDTOs.map(_workEntryMapper.fromDTO).toList();

    dayWorkEntriesList.add(
      DayWorkEntriesModel(
        day: day,
        workEntries: workEntries.isNotEmpty ? workEntries : null,
      ),
    );
  }

  return dayWorkEntriesList;
}
}
```

./lib/data/database_helper.dart:
```
import 'package:sqflite/sqflite.dart';
import 'package:timetrailblazer/data/dtos/work_entry_dto.dart';

/// La classe `DatabaseHelper` fornisce i metodi per l'accesso al database SQLite.
class DatabaseHelper {
  /// Il nome del database.
  static const String _databaseName = 'work_entries.db';

  /// La versione del database.
  static const int _databaseVersion = 1;

  /// Il nome della tabella delle voci di lavoro.
  static const String _tableWorkEntries = 'work_entries';

  /// L'istanza del database.
  static Database? _database;

  /// Restituisce l'istanza del database, creandola se non esiste.
  ///
  /// Questo metodo controlla se l'istanza del database è già stata creata.
  /// Se l'istanza non esiste, viene chiamato il metodo `_initDatabase()` per inizializzare il database.
  /// Infine, viene restituita l'istanza del database.
  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  /// Inizializza il database.
  ///
  /// Questo metodo privato viene chiamato quando l'istanza del database non esiste ancora.
  /// Recupera il percorso del database utilizzando `getDatabasesPath()` e costruisce il percorso completo.
  /// Quindi, apre il database utilizzando `openDatabase()`, specificando il percorso, la versione e il metodo `onCreate`.
  /// Il metodo `onCreate` viene chiamato quando il database viene creato per la prima volta.
  Future<Database> _initDatabase() async {
    final databasesPath = await getDatabasesPath();
    final path = '$databasesPath/$_databaseName';
    return await openDatabase(
      path,
      version: _databaseVersion,
      onCreate: _createDatabase,
    );
  }

  /// Crea le tabelle del database.
  ///
  /// Questo metodo privato viene chiamato quando il database viene creato per la prima volta.
  /// Esegue una query SQL per creare la tabella `_tableWorkEntries` con i campi `id`, `timestamp` e `isEntry`.
  /// Il campo `id` è la chiave primaria autoincrementale.
  Future<void> _createDatabase(Database db, int version) async {
    await db.execute('''
      CREATE TABLE $_tableWorkEntries (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp INTEGER NOT NULL,
        isEntry INTEGER NOT NULL
      )
    ''');
  }

  /// Inserisce una nuova voce di lavoro nel database.
  ///
  /// Riceve come parametro la [workEntryDTO] di tipo [WorkEntryDTO] da inserire.
  /// Recupera l'istanza del database chiamando il getter `database`.
  /// Esegue l'inserimento nella tabella `_tableWorkEntries` utilizzando il metodo `insert()` di SQLite.
  /// Restituisce un [Future] che si completa quando l'inserimento è stato effettuato.
  Future<void> insertWorkEntry(WorkEntryDTO workEntryDTO) async {
    final db = await database;
    await db.insert(
      _tableWorkEntries,
      workEntryDTO.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  /// Recupera l'ultima voce di lavoro inserita nel database.
  ///
  /// Recupera l'istanza del database chiamando il getter `database`.
  /// Esegue una query sulla tabella `_tableWorkEntries` utilizzando il metodo `query()` di SQLite.
  /// Ordina i risultati in base al campo `timestamp` in ordine decrescente e limita il risultato a 1 riga.
  /// Se ci sono risultati, converte la prima riga in un oggetto [WorkEntryDTO] utilizzando il metodo `fromMap()`.
  /// Restituisce un [Future] che si completa con l'ultima [WorkEntryDTO] inserita, o `null` se non ci sono voci di lavoro nel database.
  Future<WorkEntryDTO?> getLastWorkEntry() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query(
      _tableWorkEntries,
      orderBy: 'timestamp DESC',
      limit: 1,
    );
    if (maps.isNotEmpty) {
      return WorkEntryDTO.fromMap(maps.first);
    }
    return null;
  }

  /// Questo metodo esegue una query sul database per recuperare le voci di lavoro
  /// nell'intervallo di date specificato utilizzando i timestamp di inizio e di fine. Restituisce
  /// una lista di WorkEntryDTO mappando i risultati della query.
  // Future<List<WorkEntryDTO>> getWorkEntriesByDateRange(
  //     int startTimestamp, int endTimestamp) async {
  //   final db = await database;
  //   final List<Map<String, dynamic>> maps = await db.query(
  //     _tableWorkEntries,
  //     where: 'timestamp >= ? AND timestamp <= ?',
  //     whereArgs: [startTimestamp, endTimestamp],
  //     orderBy: 'timestamp DESC',
  //   );
  //   return maps.map((map) => WorkEntryDTO.fromMap(map)).toList();
  // }
  Future<List<WorkEntryDTO>> getWorkEntriesByDateRange(int startTimestamp, int endTimestamp) async {
  final db = await database;
  final List<Map<String, dynamic>> maps = await db.query(
    _tableWorkEntries,
    where: 'timestamp >= ? AND timestamp <= ?',
    whereArgs: [startTimestamp, endTimestamp],
    orderBy: 'timestamp',
  );
  return maps.map((map) => WorkEntryDTO.fromMap(map)).toList();
}
}

```

./lib/data/models/day_work_entries_model.dart:
```
import 'package:timetrailblazer/data/models/work_entry_model.dart';

class DayWorkEntriesModel {
  final DateTime day;
  final List<WorkEntryModel>? workEntries;

  DayWorkEntriesModel({required this.day, this.workEntries});
}
```

./lib/data/models/work_entry_model.dart:
```
/// La classe `WorkEntry` rappresenta il modello di dominio per una voce di lavoro.
class WorkEntryModel {
  /// L'ID univoco della voce di lavoro (può essere null per le nuove voci).
  final int? id;

  /// Il timestamp della voce di lavoro.
  final DateTime timestamp;

  /// Un flag che indica se la voce è un'entrata o un'uscita.
  final bool? isEntry;

  /// La data della voce di lavoro (senza l'ora).
  final DateTime day;

  /// Costruttore della classe `WorkEntry`.
  ///
  /// Accetta i seguenti parametri:
  /// - [id]: l'ID univoco della voce di lavoro (opzionale).
  /// - [timestamp]: il timestamp della voce di lavoro.
  /// - [isEntry]: un flag che indica se la voce è un'entrata o un'uscita.
  ///
  /// Calcola automaticamente la proprietà [day] a partire dal [timestamp].
  WorkEntryModel({
    this.id,
    required this.timestamp,
    required this.isEntry,
  }) : day = DateTime(timestamp.year, timestamp.month, timestamp.day);
}

```

./lib/di/mappers.dart:
```
import 'package:provider/provider.dart';
import 'package:provider/single_child_widget.dart';
import 'package:timetrailblazer/data/datasources/mappers/work_entry_mapper.dart';

/// Restituisce una lista di `SingleChildWidget` per l'iniezione dei mapper nell'albero dei widget.
///
/// Questa funzione configura i mapper necessari per l'applicazione, creandoli quando necessario.
/// I mapper sono responsabili della mappatura tra le entità di dominio e gli oggetti di trasferimento dati (DTO).
/// Utilizza l'approccio "lazy" per creare i mapper solo quando vengono effettivamente richiesti.
///
/// Returns:
/// - Una lista di `SingleChildWidget` contenente i mapper configurati.
List<SingleChildWidget> getMappers() {
  return [
    // Fornisce il `WorkEntryMapper` all'albero dei widget, creandolo quando necessario.
    // Il `WorkEntryMapper` è responsabile della mappatura tra `WorkEntry` e `WorkEntryDTO`.
    // Utilizza l'approccio "lazy" per creare il mapper solo quando viene effettivamente richiesto.
    Provider<WorkEntryMapper>(
      create: (_) => WorkEntryMapper(),
      lazy: true,
    ),
  ];
}
```

./lib/di/providers.dart:
```
import 'package:provider/provider.dart';
import 'package:provider/single_child_widget.dart';
import 'package:timetrailblazer/data/database_helper.dart';
import 'package:timetrailblazer/data/datasources/providers/work_entry_provider.dart';

/// Restituisce una lista di `SingleChildWidget` per l'iniezione dei provider nell'albero dei widget.
///
/// Questa funzione configura i provider necessari per l'applicazione, creandoli con le loro dipendenze.
/// I provider sono responsabili dell'accesso ai dati e della loro fornitura ai livelli superiori dell'applicazione.
/// Utilizza l'approccio "lazy" per creare i provider solo quando vengono effettivamente richiesti.
///
/// Parameters:
/// - `databaseHelper`: L'istanza di `DatabaseHelper` necessaria per creare i provider.
///
/// Returns:
/// - Una lista di `SingleChildWidget` contenente i provider configurati.
List<SingleChildWidget> getProviders(DatabaseHelper databaseHelper) {
  return [
    // Fornisce il `WorkEntriesProvider` all'albero dei widget, creandolo con il `DatabaseHelper`.
    // Il `WorkEntriesProvider` è responsabile dell'accesso ai dati delle voci di lavoro tramite il database.
    // Utilizza l'approccio "lazy" per creare il provider solo quando viene effettivamente richiesto.
    Provider<WorkEntryProvider>(
      create: (_) => WorkEntryProvider(databaseHelper),
      lazy: true,
    ),
  ];
}
```

./lib/di/repositories.dart:
```
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:timetrailblazer/data/datasources/mappers/work_entry_mapper.dart';
import 'package:timetrailblazer/data/datasources/providers/work_entry_provider.dart';
import 'package:timetrailblazer/data/datasources/repositories/work_entry_repository.dart';

/// Restituisce una lista di `RepositoryProvider` per l'iniezione dei repository nell'albero dei widget.
///
/// Questa funzione configura i repository necessari per l'applicazione, creandoli con le loro dipendenze.
/// I repository sono responsabili dell'accesso ai dati e della loro gestione, fungendo da intermediari tra i provider e i BLoC.
/// Utilizza l'approccio "lazy" per creare i repository solo quando vengono effettivamente richiesti.
///
/// Returns:
/// - Una lista di `RepositoryProvider` contenente i repository configurati.
List<RepositoryProvider<dynamic>> getRepositories() {
  return [
    // Fornisce il `WorkEntriesRepository` all'albero dei widget, creandolo con il `WorkEntriesProvider` e il `WorkEntryMapper`.
    // Il `WorkEntriesRepository` è responsabile dell'accesso ai dati delle voci di lavoro e della loro gestione.
    // Utilizza l'approccio "lazy" per creare il repository solo quando viene effettivamente richiesto.
    RepositoryProvider<WorkEntryRepository>(
      create: (context) => WorkEntryRepository(
        context.read<WorkEntryProvider>(),
        context.read<WorkEntryMapper>(),
      ),
      lazy: true,
    ),
  ];
}

```

./lib/di/bloc_providers.dart:
```
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:timetrailblazer/data/datasources/repositories/work_entry_repository.dart';
import 'package:timetrailblazer/domain/blocs/home_page/home_bloc.dart';
import 'package:timetrailblazer/domain/blocs/work_entries/work_entries_bloc.dart';

/// Restituisce una lista di `BlocProvider` per l'iniezione dei BLoC nell'albero dei widget.
///
/// Questa funzione configura i BLoC necessari per l'applicazione, creandoli con le loro dipendenze.
/// I BLoC sono responsabili della gestione dello stato e della logica di business dell'applicazione.
/// Utilizza l'approccio "lazy" per creare i BLoC solo quando vengono effettivamente richiesti.
///
/// Returns:
/// - Una lista di `BlocProvider` contenente i BLoC configurati.
List<BlocProvider<StateStreamableSource<Object?>>> getBlocProviders() {
  return [
    // Fornisce il `WorkEntriesBloc` all'albero dei widget, creandolo con il `WorkEntriesRepository`.
    // Il `WorkEntriesBloc` è responsabile della gestione dello stato relativo alle voci di lavoro.
    // Utilizza l'approccio "lazy" per creare il BLoC solo quando viene effettivamente richiesto.

    BlocProvider<WorkEntriesBloc>(
      create: (context) => WorkEntriesBloc(
        context.read<WorkEntryRepository>(),
      ),
      lazy: true,
    ),

    // Fornisce il `HomeBloc` all'albero dei widget, creandolo senza dipendenze esterne.
    // Il `HomeBloc` è responsabile della gestione dello stato relativo alla schermata principale dell'applicazione.
    // Utilizza l'approccio "lazy" per creare il BLoC solo quando viene effettivamente richiesto.
    BlocProvider<HomeBloc>(
      create: (context) => HomeBloc(
        context.read<WorkEntryRepository>(),
      ),
      lazy: true,
    ),
  ];
}

```

./lib/app_initializer.dart:
```
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:intl/date_symbol_data_local.dart';
import 'package:pine/pine.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:timetrailblazer/app.dart';
import 'package:timetrailblazer/data/database_helper.dart';
import 'package:timetrailblazer/di/bloc_providers.dart';
import 'package:timetrailblazer/di/mappers.dart';
import 'package:timetrailblazer/di/providers.dart';
import 'package:timetrailblazer/di/repositories.dart';

/// La classe `AppInitializer` contiene la logica di inizializzazione dell'app.
///
/// Questa classe si occupa di inizializzare il database, configurare le dipendenze
/// e restituire il widget root dell'applicazione.
class AppInitializer {
  /// Inizializza l'applicazione.
  ///
  /// Questo metodo esegue le seguenti operazioni:
  /// 1. Assicura che i binding di Flutter siano inizializzati.
  /// 2. Inizializza la formattazione delle date per la lingua italiana.
  /// 3. Verifica se l'app è in esecuzione su Windows o Linux e inizializza FFI se necessario.
  /// 4. Crea un'istanza di `DatabaseHelper` per gestire il database dell'app.
  /// 5. Utilizza un `FutureBuilder` per inizializzare il database e configurare le dipendenze.
  /// 6. In caso di errore durante l'inizializzazione del database, mostra un messaggio di errore.
  /// 7. Altrimenti, restituisce il widget root dell'app con le dipendenze configurate.
  static Future<Widget> initialize() async {
    WidgetsFlutterBinding.ensureInitialized();
    await initializeDateFormatting('it_IT', null);

    if (Platform.isWindows || Platform.isLinux) {
      sqfliteFfiInit();
      databaseFactory = databaseFactoryFfi;
    }

    final databaseHelper = DatabaseHelper();

    return FutureBuilder(
      future:  databaseHelper.database,
      builder: (context, snapshot) {
        // if (snapshot.connectionState == ConnectionState.done) {
          if (snapshot.hasError) {
            return MaterialApp(
              home: Scaffold(
                body: Center(
                  child: Text(
                    'Errore durante l\'inizializzazione del database: ${snapshot.error}. Si prega di verificare che il dispositivo abbia spazio sufficiente e che l\'applicazione abbia i permessi necessari per creare il database. Se il problema persiste, contattare l\'assistenza.',
                  ),
                ),
              ),
            );
          } else {
            return DependencyInjectorHelper(
               mappers: getMappers(),
               providers: getProviders(databaseHelper),
               repositories: getRepositories(),
               blocs: getBlocProviders(),
              child: const App(),
            );
          }
        // } else {
        //   return const MaterialApp(
        //     home: Scaffold(
        //       body: Center(
        //         child: CircularProgressIndicator(),
        //       ),
        //     ),
        //   );
        // }
      },
    );
  }
}

```

